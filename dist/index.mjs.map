{"version":3,"sources":["../play-dl/Request/index.ts","../play-dl/YouTube/utils/cookie.ts","../play-dl/Request/useragent.ts","../play-dl/YouTube/classes/LiveStream.ts","../play-dl/YouTube/utils/cipher.ts","../play-dl/YouTube/classes/Channel.ts","../play-dl/YouTube/classes/Thumbnail.ts","../play-dl/YouTube/classes/Video.ts","../play-dl/YouTube/classes/Playlist.ts","../play-dl/YouTube/utils/extractor.ts","../play-dl/YouTube/classes/WebmSeeker.ts","../play-dl/YouTube/classes/SeekStream.ts","../play-dl/YouTube/stream.ts","../play-dl/YouTube/utils/parser.ts","../play-dl/YouTube/search.ts","../play-dl/Spotify/classes.ts","../play-dl/Spotify/index.ts","../play-dl/SoundCloud/index.ts","../play-dl/SoundCloud/classes.ts","../play-dl/Deezer/index.ts","../play-dl/Deezer/classes.ts","../play-dl/token.ts","../play-dl/index.ts"],"sourcesContent":["import { IncomingMessage } from 'node:http';\nimport { RequestOptions, request as httpsRequest } from 'node:https';\nimport { URL } from 'node:url';\nimport { BrotliDecompress, Deflate, Gunzip, createGunzip, createBrotliDecompress, createDeflate } from 'node:zlib';\nimport { cookieHeaders, getCookies } from '../YouTube/utils/cookie';\nimport { getRandomUserAgent } from './useragent';\n\ninterface RequestOpts extends RequestOptions {\n    body?: string;\n    method?: 'GET' | 'POST' | 'HEAD';\n    cookies?: boolean;\n    cookieJar?: { [key: string]: string };\n}\n\n/**\n * Main module which play-dl uses to make a request to stream url.\n * @param url URL to make https request to\n * @param options Request options for https request\n * @returns IncomingMessage from the request\n */\nexport function request_stream(req_url: string, options: RequestOpts = { method: 'GET' }): Promise<IncomingMessage> {\n    return new Promise(async (resolve, reject) => {\n        let res = await https_getter(req_url, options).catch((err: Error) => err);\n        if (res instanceof Error) {\n            reject(res);\n            return;\n        }\n        if (Number(res.statusCode) >= 300 && Number(res.statusCode) < 400) {\n            res = await request_stream(res.headers.location as string, options);\n        }\n        resolve(res);\n    });\n}\n/**\n * Makes a request and follows redirects if necessary\n * @param req_url URL to make https request to\n * @param options Request options for https request\n * @returns A promise with the final response object\n */\nfunction internalRequest(req_url: string, options: RequestOpts = { method: 'GET' }): Promise<IncomingMessage> {\n    return new Promise(async (resolve, reject) => {\n        let res = await https_getter(req_url, options).catch((err: Error) => err);\n        if (res instanceof Error) {\n            reject(res);\n            return;\n        }\n        if (Number(res.statusCode) >= 300 && Number(res.statusCode) < 400) {\n            res = await internalRequest(res.headers.location as string, options);\n        } else if (Number(res.statusCode) > 400) {\n            reject(new Error(`Got ${res.statusCode} from the request`));\n            return;\n        }\n        resolve(res);\n    });\n}\n/**\n * Main module which play-dl uses to make a request\n * @param url URL to make https request to\n * @param options Request options for https request\n * @returns body of that request\n */\nexport function request(req_url: string, options: RequestOpts = { method: 'GET' }): Promise<string> {\n    return new Promise(async (resolve, reject) => {\n        let cookies_added = false;\n        if (options.cookies) {\n            let cook = getCookies();\n            if (typeof cook === 'string' && options.headers) {\n                Object.assign(options.headers, { cookie: cook });\n                cookies_added = true;\n            }\n        }\n        if (options.cookieJar) {\n            const cookies = [];\n            for (const cookie of Object.entries(options.cookieJar)) {\n                cookies.push(cookie.join('='));\n            }\n\n            if (cookies.length !== 0) {\n                if (!options.headers) options.headers = {};\n                const existingCookies = cookies_added ? `; ${options.headers.cookie}` : '';\n                Object.assign(options.headers, { cookie: `${cookies.join('; ')}${existingCookies}` });\n            }\n        }\n        if (options.headers) {\n            options.headers = {\n                ...options.headers,\n                'accept-encoding': 'gzip, deflate, br',\n                'user-agent': getRandomUserAgent()\n            };\n        }\n        const res = await internalRequest(req_url, options).catch((err: Error) => err);\n        if (res instanceof Error) {\n            reject(res);\n            return;\n        }\n        if (res.headers && res.headers['set-cookie']) {\n            if (options.cookieJar) {\n                for (const cookie of res.headers['set-cookie']) {\n                    const parts = cookie.split(';')[0].trim().split('=');\n                    options.cookieJar[parts.shift() as string] = parts.join('=');\n                }\n            }\n            if (cookies_added) {\n                cookieHeaders(res.headers['set-cookie']);\n            }\n        }\n        const data: string[] = [];\n        let decoder: BrotliDecompress | Gunzip | Deflate | undefined = undefined;\n        const encoding = res.headers['content-encoding'];\n        if (encoding === 'gzip') decoder = createGunzip();\n        else if (encoding === 'br') decoder = createBrotliDecompress();\n        else if (encoding === 'deflate') decoder = createDeflate();\n\n        if (decoder) {\n            res.pipe(decoder);\n            decoder.setEncoding('utf-8');\n            decoder.on('data', (c) => data.push(c));\n            decoder.on('end', () => resolve(data.join('')));\n        } else {\n            res.setEncoding('utf-8');\n            res.on('data', (c) => data.push(c));\n            res.on('end', () => resolve(data.join('')));\n        }\n    });\n}\n\nexport function request_resolve_redirect(url: string): Promise<string> {\n    return new Promise(async (resolve, reject) => {\n        let res = await https_getter(url, { method: 'HEAD' }).catch((err: Error) => err);\n        if (res instanceof Error) {\n            reject(res);\n            return;\n        }\n        const statusCode = Number(res.statusCode);\n        if (statusCode < 300) {\n            resolve(url);\n        } else if (statusCode < 400) {\n            const resolved = await request_resolve_redirect(res.headers.location as string).catch((err) => err);\n            if (resolved instanceof Error) {\n                reject(resolved);\n                return;\n            }\n\n            resolve(resolved);\n        } else {\n            reject(new Error(`${res.statusCode}: ${res.statusMessage}, ${url}`));\n        }\n    });\n}\n\nexport function request_content_length(url: string): Promise<number> {\n    return new Promise(async (resolve, reject) => {\n        let res = await https_getter(url, { method: 'HEAD' }).catch((err: Error) => err);\n        if (res instanceof Error) {\n            reject(res);\n            return;\n        }\n        const statusCode = Number(res.statusCode);\n        if (statusCode < 300) {\n            resolve(Number(res.headers['content-length']));\n        } else if (statusCode < 400) {\n            const newURL = await request_resolve_redirect(res.headers.location as string).catch((err) => err);\n            if (newURL instanceof Error) {\n                reject(newURL);\n                return;\n            }\n\n            const res2 = await request_content_length(newURL).catch((err) => err);\n            if (res2 instanceof Error) {\n                reject(res2);\n                return;\n            }\n\n            resolve(res2);\n        } else {\n            reject(\n                new Error(`Failed to get content length with error: ${res.statusCode}, ${res.statusMessage}, ${url}`)\n            );\n        }\n    });\n}\n\n/**\n * Main module that play-dl uses for making a https request\n * @param req_url URL to make https request to\n * @param options Request options for https request\n * @returns Incoming Message from the https request\n */\nfunction https_getter(req_url: string, options: RequestOpts = {}): Promise<IncomingMessage> {\n    return new Promise((resolve, reject) => {\n        const s = new URL(req_url);\n        options.method ??= 'GET';\n        const req_options: RequestOptions = {\n            host: s.hostname,\n            path: s.pathname + s.search,\n            headers: options.headers ?? {},\n            method: options.method\n        };\n\n        const req = httpsRequest(req_options, resolve);\n        req.on('error', (err) => {\n            reject(err);\n        });\n        if (options.method === 'POST') req.write(options.body);\n        req.end();\n    });\n}\n","import { existsSync, readFileSync, writeFileSync } from 'node:fs';\n\nlet youtubeData: youtubeDataOptions;\nif (existsSync('.data/youtube.data')) {\n    youtubeData = JSON.parse(readFileSync('.data/youtube.data', 'utf-8'));\n    youtubeData.file = true;\n}\n\ninterface youtubeDataOptions {\n    cookie?: Object;\n    file?: boolean;\n}\n\nexport function getCookies(): undefined | string {\n    let result = '';\n    if (!youtubeData?.cookie) return undefined;\n    for (const [key, value] of Object.entries(youtubeData.cookie)) {\n        result += `${key}=${value};`;\n    }\n    return result;\n}\n\nexport function setCookie(key: string, value: string): boolean {\n    if (!youtubeData?.cookie) return false;\n    key = key.trim();\n    value = value.trim();\n    Object.assign(youtubeData.cookie, { [key]: value });\n    return true;\n}\n\nexport function uploadCookie() {\n    if (youtubeData.cookie && youtubeData.file)\n        writeFileSync('.data/youtube.data', JSON.stringify(youtubeData, undefined, 4));\n}\n\nexport function setCookieToken(options: { cookie: string }) {\n    let cook = options.cookie;\n    let cookie: Object = {};\n    cook.split(';').forEach((x) => {\n        const arr = x.split('=');\n        if (arr.length <= 1) return;\n        const key = arr.shift()?.trim() as string;\n        const value = arr.join('=').trim();\n        Object.assign(cookie, { [key]: value });\n    });\n    youtubeData = { cookie };\n    youtubeData.file = false;\n}\n\n/**\n * Updates cookies locally either in file or in memory.\n *\n * Example\n * ```ts\n * const response = ... // Any https package get function.\n *\n * play.cookieHeaders(response.headers['set-cookie'])\n * ```\n * @param headCookie response headers['set-cookie'] array\n * @returns Nothing\n */\nexport function cookieHeaders(headCookie: string[]): void {\n    if (!youtubeData?.cookie) return;\n    headCookie.forEach((x: string) => {\n        x.split(';').forEach((z) => {\n            const arr = z.split('=');\n            if (arr.length <= 1) return;\n            const key = arr.shift()?.trim() as string;\n            const value = arr.join('=').trim();\n            setCookie(key, value);\n        });\n    });\n    uploadCookie();\n}\n","import useragents from './useragents.json';\n\nexport function setUserAgent(array: string[]): void {\n    useragents.push(...array);\n}\n\nfunction getRandomInt(min: number, max: number): number {\n    min = Math.ceil(min);\n    max = Math.floor(max);\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\nexport function getRandomUserAgent() {\n    const random = getRandomInt(0, useragents.length - 1);\n    return useragents[random];\n}\n","import { Readable } from 'node:stream';\nimport { IncomingMessage } from 'node:http';\nimport { parseAudioFormats, StreamOptions, StreamType } from '../stream';\nimport { request, request_stream } from '../../Request';\nimport { video_stream_info } from '../utils/extractor';\nimport { URL } from 'node:url';\n\n/**\n * YouTube Live Stream class for playing audio from Live Stream videos.\n */\nexport class LiveStream {\n    /**\n     * Readable Stream through which data passes\n     */\n    stream: Readable;\n    /**\n     * Type of audio data that we recieved from live stream youtube url.\n     */\n    type: StreamType;\n    /**\n     * Incoming message that we recieve.\n     *\n     * Storing this is essential.\n     * This helps to destroy the TCP connection completely if you stopped player in between the stream\n     */\n    private request?: IncomingMessage;\n    /**\n     * Timer that creates loop from interval time provided.\n     */\n    private normal_timer?: Timer;\n    /**\n     * Timer used to update dash url so as to avoid 404 errors after long hours of streaming.\n     *\n     * It updates dash_url every 30 minutes.\n     */\n    private dash_timer: Timer;\n    /**\n     * Given Dash URL.\n     */\n    private dash_url: string;\n    /**\n     * Base URL in dash manifest file.\n     */\n    private base_url: string;\n    /**\n     * Interval to fetch data again to dash url.\n     */\n    private interval: number;\n    /**\n     * Timer used to update dash url so as to avoid 404 errors after long hours of streaming.\n     *\n     * It updates dash_url every 30 minutes.\n     */\n    private video_url: string;\n    /**\n     * No of segments of data to add in stream before starting to loop\n     */\n    private precache: number;\n    /**\n     * Segment sequence number\n     */\n    private sequence: number;\n    /**\n     * Live Stream Class Constructor\n     * @param dash_url dash manifest URL\n     * @param target_interval interval time for fetching dash data again\n     * @param video_url Live Stream video url.\n     */\n    constructor(dash_url: string, interval: number, video_url: string, precache?: number) {\n        this.stream = new Readable({ highWaterMark: 5 * 1000 * 1000, read() {} });\n        this.type = StreamType.Arbitrary;\n        this.sequence = 0;\n        this.dash_url = dash_url;\n        this.base_url = '';\n        this.interval = interval;\n        this.video_url = video_url;\n        this.precache = precache || 3;\n        this.dash_timer = new Timer(() => {\n            this.dash_updater();\n            this.dash_timer.reuse();\n        }, 1800);\n        this.stream.on('close', () => {\n            this.cleanup();\n        });\n        this.initialize_dash();\n    }\n    /**\n     * This cleans every used variable in class.\n     *\n     * This is used to prevent re-use of this class and helping garbage collector to collect it.\n     */\n    private cleanup() {\n        this.normal_timer?.destroy();\n        this.dash_timer.destroy();\n        this.request?.destroy();\n        this.video_url = '';\n        this.request = undefined;\n        this.dash_url = '';\n        this.base_url = '';\n        this.interval = 0;\n    }\n    /**\n     * Updates dash url.\n     *\n     * Used by dash_timer for updating dash_url every 30 minutes.\n     */\n    private async dash_updater() {\n        const info = await video_stream_info(this.video_url);\n        if (info.LiveStreamData.dashManifestUrl) this.dash_url = info.LiveStreamData.dashManifestUrl;\n        return this.initialize_dash();\n    }\n    /**\n     * Initializes dash after getting dash url.\n     *\n     * Start if it is first time of initialishing dash function.\n     */\n    private async initialize_dash() {\n        const response = await request(this.dash_url);\n        const audioFormat = response\n            .split('<AdaptationSet id=\"0\"')[1]\n            .split('</AdaptationSet>')[0]\n            .split('</Representation>');\n        if (audioFormat[audioFormat.length - 1] === '') audioFormat.pop();\n        this.base_url = audioFormat[audioFormat.length - 1].split('<BaseURL>')[1].split('</BaseURL>')[0];\n        await request_stream(`https://${new URL(this.base_url).host}/generate_204`);\n        if (this.sequence === 0) {\n            const list = audioFormat[audioFormat.length - 1]\n                .split('<SegmentList>')[1]\n                .split('</SegmentList>')[0]\n                .replaceAll('<SegmentURL media=\"', '')\n                .split('\"/>');\n            if (list[list.length - 1] === '') list.pop();\n            if (list.length > this.precache) list.splice(0, list.length - this.precache);\n            this.sequence = Number(list[0].split('sq/')[1].split('/')[0]);\n            this.first_data(list.length);\n        }\n    }\n    /**\n     * Used only after initializing dash function first time.\n     * @param len Length of data that you want to\n     */\n    private async first_data(len: number) {\n        for (let i = 1; i <= len; i++) {\n            await new Promise(async (resolve) => {\n                const stream = await request_stream(this.base_url + 'sq/' + this.sequence).catch((err: Error) => err);\n                if (stream instanceof Error) {\n                    this.stream.emit('error', stream);\n                    return;\n                }\n                this.request = stream;\n                stream.on('data', (c) => {\n                    this.stream.push(c);\n                });\n                stream.on('end', () => {\n                    this.sequence++;\n                    resolve('');\n                });\n                stream.once('error', (err) => {\n                    this.stream.emit('error', err);\n                });\n            });\n        }\n        this.normal_timer = new Timer(() => {\n            this.loop();\n            this.normal_timer?.reuse();\n        }, this.interval);\n    }\n    /**\n     * This loops function in Live Stream Class.\n     *\n     * Gets next segment and push it.\n     */\n    private loop() {\n        return new Promise(async (resolve) => {\n            const stream = await request_stream(this.base_url + 'sq/' + this.sequence).catch((err: Error) => err);\n            if (stream instanceof Error) {\n                this.stream.emit('error', stream);\n                return;\n            }\n            this.request = stream;\n            stream.on('data', (c) => {\n                this.stream.push(c);\n            });\n            stream.on('end', () => {\n                this.sequence++;\n                resolve('');\n            });\n            stream.once('error', (err) => {\n                this.stream.emit('error', err);\n            });\n        });\n    }\n    /**\n     * Deprecated Functions\n     */\n    pause() {}\n    /**\n     * Deprecated Functions\n     */\n    resume() {}\n}\n/**\n * YouTube Stream Class for playing audio from normal videos.\n */\nexport class Stream {\n    /**\n     * Readable Stream through which data passes\n     */\n    stream: Readable;\n    /**\n     * Type of audio data that we recieved from normal youtube url.\n     */\n    type: StreamType;\n    /**\n     * Audio Endpoint Format Url to get data from.\n     */\n    private url: string;\n    /**\n     * Used to calculate no of bytes data that we have recieved\n     */\n    private bytes_count: number;\n    /**\n     * Calculate per second bytes by using contentLength (Total bytes) / Duration (in seconds)\n     */\n    private per_sec_bytes: number;\n    /**\n     * Total length of audio file in bytes\n     */\n    private content_length: number;\n    /**\n     * YouTube video url. [ Used only for retrying purposes only. ]\n     */\n    private video_url: string;\n    /**\n     * Timer for looping data every 265 seconds.\n     */\n    private timer: Timer;\n    /**\n     * Quality given by user. [ Used only for retrying purposes only. ]\n     */\n    private quality: number;\n    /**\n     * Incoming message that we recieve.\n     *\n     * Storing this is essential.\n     * This helps to destroy the TCP connection completely if you stopped player in between the stream\n     */\n    private request: IncomingMessage | null;\n    /**\n     * YouTube Stream Class constructor\n     * @param url Audio Endpoint url.\n     * @param type Type of Stream\n     * @param duration Duration of audio playback [ in seconds ]\n     * @param contentLength Total length of Audio file in bytes.\n     * @param video_url YouTube video url.\n     * @param options Options provided to stream function.\n     */\n    constructor(\n        url: string,\n        type: StreamType,\n        duration: number,\n        contentLength: number,\n        video_url: string,\n        options: StreamOptions\n    ) {\n        this.stream = new Readable({ highWaterMark: 5 * 1000 * 1000, read() {} });\n        this.url = url;\n        this.quality = options.quality as number;\n        this.type = type;\n        this.bytes_count = 0;\n        this.video_url = video_url;\n        this.per_sec_bytes = Math.ceil(contentLength / duration);\n        this.content_length = contentLength;\n        this.request = null;\n        this.timer = new Timer(() => {\n            this.timer.reuse();\n            this.loop();\n        }, 265);\n        this.stream.on('close', () => {\n            this.timer.destroy();\n            this.cleanup();\n        });\n        this.loop();\n    }\n    /**\n     * Retry if we get 404 or 403 Errors.\n     */\n    private async retry() {\n        const info = await video_stream_info(this.video_url);\n        const audioFormat = parseAudioFormats(info.format);\n        this.url = audioFormat[this.quality].url;\n    }\n    /**\n     * This cleans every used variable in class.\n     *\n     * This is used to prevent re-use of this class and helping garbage collector to collect it.\n     */\n    private cleanup() {\n        this.request?.destroy();\n        this.request = null;\n        this.url = '';\n    }\n    /**\n     * Getting data from audio endpoint url and passing it to stream.\n     *\n     * If 404 or 403 occurs, it will retry again.\n     */\n    private async loop() {\n        if (this.stream.destroyed) {\n            this.timer.destroy();\n            this.cleanup();\n            return;\n        }\n        const end: number = this.bytes_count + this.per_sec_bytes * 300;\n        const stream = await request_stream(this.url, {\n            headers: {\n                range: `bytes=${this.bytes_count}-${end >= this.content_length ? '' : end}`\n            }\n        }).catch((err: Error) => err);\n        if (stream instanceof Error) {\n            this.stream.emit('error', stream);\n            this.bytes_count = 0;\n            this.per_sec_bytes = 0;\n            this.cleanup();\n            return;\n        }\n        if (Number(stream.statusCode) >= 400) {\n            this.cleanup();\n            await this.retry();\n            this.timer.reuse();\n            this.loop();\n            return;\n        }\n        this.request = stream;\n        stream.on('data', (c) => {\n            this.stream.push(c);\n        });\n\n        stream.once('error', async () => {\n            this.cleanup();\n            await this.retry();\n            this.timer.reuse();\n            this.loop();\n        });\n\n        stream.on('data', (chunk: any) => {\n            this.bytes_count += chunk.length;\n        });\n\n        stream.on('end', () => {\n            if (end >= this.content_length) {\n                this.timer.destroy();\n                this.stream.push(null);\n                this.cleanup();\n            }\n        });\n    }\n    /**\n     * Pauses timer.\n     * Stops running of loop.\n     *\n     * Useful if you don't want to get excess data to be stored in stream.\n     */\n    pause() {\n        this.timer.pause();\n    }\n    /**\n     * Resumes timer.\n     * Starts running of loop.\n     */\n    resume() {\n        this.timer.resume();\n    }\n}\n/**\n * Timer Class.\n *\n * setTimeout + extra features ( re-starting, pausing, resuming ).\n */\nexport class Timer {\n    /**\n     * Boolean for checking if Timer is destroyed or not.\n     */\n    private destroyed: boolean;\n    /**\n     * Boolean for checking if Timer is paused or not.\n     */\n    private paused: boolean;\n    /**\n     * setTimeout function\n     */\n    private timer: NodeJS.Timer;\n    /**\n     * Callback to be executed once timer finishes.\n     */\n    private callback: () => void;\n    /**\n     * Seconds time when it is started.\n     */\n    private time_start: number;\n    /**\n     * Total time left.\n     */\n    private time_left: number;\n    /**\n     * Total time given by user [ Used only for re-using timer. ]\n     */\n    private time_total: number;\n    /**\n     * Constructor for Timer Class\n     * @param callback Function to execute when timer is up.\n     * @param time Total time to wait before execution.\n     */\n    constructor(callback: () => void, time: number) {\n        this.callback = callback;\n        this.time_total = time;\n        this.time_left = time;\n        this.paused = false;\n        this.destroyed = false;\n        this.time_start = process.hrtime()[0];\n        this.timer = setTimeout(this.callback, this.time_total * 1000);\n    }\n    /**\n     * Pauses Timer\n     * @returns Boolean to tell that if it is paused or not.\n     */\n    pause() {\n        if (!this.paused && !this.destroyed) {\n            this.paused = true;\n            clearTimeout(this.timer);\n            this.time_left = this.time_left - (process.hrtime()[0] - this.time_start);\n            return true;\n        } else return false;\n    }\n    /**\n     * Resumes Timer\n     * @returns Boolean to tell that if it is resumed or not.\n     */\n    resume() {\n        if (this.paused && !this.destroyed) {\n            this.paused = false;\n            this.time_start = process.hrtime()[0];\n            this.timer = setTimeout(this.callback, this.time_left * 1000);\n            return true;\n        } else return false;\n    }\n    /**\n     * Reusing of timer\n     * @returns Boolean to tell if it is re-used or not.\n     */\n    reuse() {\n        if (!this.destroyed) {\n            clearTimeout(this.timer);\n            this.time_left = this.time_total;\n            this.paused = false;\n            this.time_start = process.hrtime()[0];\n            this.timer = setTimeout(this.callback, this.time_total * 1000);\n            return true;\n        } else return false;\n    }\n    /**\n     * Destroy timer.\n     *\n     * It can't be used again.\n     */\n    destroy() {\n        clearTimeout(this.timer);\n        this.destroyed = true;\n        this.callback = () => {};\n        this.time_total = 0;\n        this.time_left = 0;\n        this.paused = false;\n        this.time_start = 0;\n    }\n}\n","import { URL, URLSearchParams } from 'node:url';\nimport { request } from './../../Request';\n\ninterface formatOptions {\n    url?: string;\n    sp?: string;\n    signatureCipher?: string;\n    cipher?: string;\n    s?: string;\n}\n// RegExp for various js functions\nconst var_js = '[a-zA-Z_\\\\$]\\\\w*';\nconst singlequote_js = `'[^'\\\\\\\\]*(:?\\\\\\\\[\\\\s\\\\S][^'\\\\\\\\]*)*'`;\nconst duoblequote_js = `\"[^\"\\\\\\\\]*(:?\\\\\\\\[\\\\s\\\\S][^\"\\\\\\\\]*)*\"`;\nconst quote_js = `(?:${singlequote_js}|${duoblequote_js})`;\nconst key_js = `(?:${var_js}|${quote_js})`;\nconst prop_js = `(?:\\\\.${var_js}|\\\\[${quote_js}\\\\])`;\nconst empty_js = `(?:''|\"\")`;\nconst reverse_function = ':function\\\\(a\\\\)\\\\{' + '(?:return )?a\\\\.reverse\\\\(\\\\)' + '\\\\}';\nconst slice_function = ':function\\\\(a,b\\\\)\\\\{' + 'return a\\\\.slice\\\\(b\\\\)' + '\\\\}';\nconst splice_function = ':function\\\\(a,b\\\\)\\\\{' + 'a\\\\.splice\\\\(0,b\\\\)' + '\\\\}';\nconst swap_function =\n    ':function\\\\(a,b\\\\)\\\\{' +\n    'var c=a\\\\[0\\\\];a\\\\[0\\\\]=a\\\\[b(?:%a\\\\.length)?\\\\];a\\\\[b(?:%a\\\\.length)?\\\\]=c(?:;return a)?' +\n    '\\\\}';\nconst obj_regexp = new RegExp(\n    `var (${var_js})=\\\\{((?:(?:${key_js}${reverse_function}|${key_js}${slice_function}|${key_js}${splice_function}|${key_js}${swap_function}),?\\\\r?\\\\n?)+)\\\\};`\n);\nconst function_regexp = new RegExp(\n    `${\n        `function(?: ${var_js})?\\\\(a\\\\)\\\\{` + `a=a\\\\.split\\\\(${empty_js}\\\\);\\\\s*` + `((?:(?:a=)?${var_js}`\n    }${prop_js}\\\\(a,\\\\d+\\\\);)+)` +\n        `return a\\\\.join\\\\(${empty_js}\\\\)` +\n        `\\\\}`\n);\nconst reverse_regexp = new RegExp(`(?:^|,)(${key_js})${reverse_function}`, 'm');\nconst slice_regexp = new RegExp(`(?:^|,)(${key_js})${slice_function}`, 'm');\nconst splice_regexp = new RegExp(`(?:^|,)(${key_js})${splice_function}`, 'm');\nconst swap_regexp = new RegExp(`(?:^|,)(${key_js})${swap_function}`, 'm');\n/**\n * Function to get tokens from html5player body data.\n * @param body body data of html5player.\n * @returns Array of tokens.\n */\nfunction js_tokens(body: string) {\n    const function_action = function_regexp.exec(body);\n    const object_action = obj_regexp.exec(body);\n    if (!function_action || !object_action) return null;\n\n    const object = object_action[1].replace(/\\$/g, '\\\\$');\n    const object_body = object_action[2].replace(/\\$/g, '\\\\$');\n    const function_body = function_action[1].replace(/\\$/g, '\\\\$');\n\n    let result = reverse_regexp.exec(object_body);\n    const reverseKey = result && result[1].replace(/\\$/g, '\\\\$').replace(/\\$|^'|^\"|'$|\"$/g, '');\n\n    result = slice_regexp.exec(object_body);\n    const sliceKey = result && result[1].replace(/\\$/g, '\\\\$').replace(/\\$|^'|^\"|'$|\"$/g, '');\n\n    result = splice_regexp.exec(object_body);\n    const spliceKey = result && result[1].replace(/\\$/g, '\\\\$').replace(/\\$|^'|^\"|'$|\"$/g, '');\n\n    result = swap_regexp.exec(object_body);\n    const swapKey = result && result[1].replace(/\\$/g, '\\\\$').replace(/\\$|^'|^\"|'$|\"$/g, '');\n\n    const keys = `(${[reverseKey, sliceKey, spliceKey, swapKey].join('|')})`;\n    const myreg = `(?:a=)?${object}(?:\\\\.${keys}|\\\\['${keys}'\\\\]|\\\\[\"${keys}\"\\\\])` + `\\\\(a,(\\\\d+)\\\\)`;\n    const tokenizeRegexp = new RegExp(myreg, 'g');\n    const tokens = [];\n    while ((result = tokenizeRegexp.exec(function_body)) !== null) {\n        const key = result[1] || result[2] || result[3];\n        switch (key) {\n            case swapKey:\n                tokens.push(`sw${result[4]}`);\n                break;\n            case reverseKey:\n                tokens.push('rv');\n                break;\n            case sliceKey:\n                tokens.push(`sl${result[4]}`);\n                break;\n            case spliceKey:\n                tokens.push(`sp${result[4]}`);\n                break;\n        }\n    }\n    return tokens;\n}\n/**\n * Function to decipher signature\n * @param tokens Tokens from js_tokens function\n * @param signature Signatured format url\n * @returns deciphered signature\n */\nfunction deciper_signature(tokens: string[], signature: string) {\n    let sig = signature.split('');\n    const len = tokens.length;\n    for (let i = 0; i < len; i++) {\n        let token = tokens[i],\n            pos;\n        switch (token.slice(0, 2)) {\n            case 'sw':\n                pos = parseInt(token.slice(2));\n                swappositions(sig, pos);\n                break;\n            case 'rv':\n                sig.reverse();\n                break;\n            case 'sl':\n                pos = parseInt(token.slice(2));\n                sig = sig.slice(pos);\n                break;\n            case 'sp':\n                pos = parseInt(token.slice(2));\n                sig.splice(0, pos);\n                break;\n        }\n    }\n    return sig.join('');\n}\n/**\n * Function to swap positions in a array\n * @param array array\n * @param position position to switch with first element\n */\nfunction swappositions(array: string[], position: number) {\n    const first = array[0];\n    array[0] = array[position];\n    array[position] = first;\n}\n/**\n * Sets Download url with some extra parameter\n * @param format video fomat\n * @param sig deciphered signature\n * @returns void\n */\nfunction download_url(format: formatOptions, sig: string) {\n    if (!format.url) return;\n\n    const decoded_url = decodeURIComponent(format.url);\n\n    const parsed_url = new URL(decoded_url);\n    parsed_url.searchParams.set('ratebypass', 'yes');\n\n    if (sig) {\n        parsed_url.searchParams.set(format.sp || 'signature', sig);\n    }\n    format.url = parsed_url.toString();\n}\n/**\n * Main function which handles all queries related to video format deciphering\n * @param formats video formats\n * @param html5player url of html5player\n * @returns array of format.\n */\nexport async function format_decipher(formats: formatOptions[], html5player: string): Promise<formatOptions[]> {\n    const body = await request(html5player);\n    const tokens = js_tokens(body);\n    formats.forEach((format) => {\n        const cipher = format.signatureCipher || format.cipher;\n        if (cipher) {\n            const params = Object.fromEntries(new URLSearchParams(cipher));\n            Object.assign(format, params);\n            delete format.signatureCipher;\n            delete format.cipher;\n        }\n        if (tokens && format.s) {\n            const sig = deciper_signature(tokens, format.s);\n            download_url(format, sig);\n            delete format.s;\n            delete format.sp;\n        }\n    });\n    return formats;\n}\n","export interface ChannelIconInterface {\n    /**\n     * YouTube Channel Icon URL\n     */\n    url: string;\n    /**\n     * YouTube Channel Icon Width\n     */\n    width: number;\n    /**\n     * YouTube Channel Icon Height\n     */\n    height: number;\n}\n/**\n * YouTube Channel Class\n */\nexport class YouTubeChannel {\n    /**\n     * YouTube Channel Title\n     */\n    name?: string;\n    /**\n     * YouTube Channel Verified status.\n     */\n    verified?: boolean;\n    /**\n     * YouTube Channel artist if any.\n     */\n    artist?: boolean;\n    /**\n     * YouTube Channel ID.\n     */\n    id?: string;\n    /**\n     * YouTube Class type. == \"channel\"\n     */\n    type: 'video' | 'playlist' | 'channel';\n    /**\n     * YouTube Channel Url\n     */\n    url?: string;\n    /**\n     * YouTube Channel Icons data.\n     */\n    icons?: ChannelIconInterface[];\n    /**\n     * YouTube Channel subscribers count.\n     */\n    subscribers?: string;\n    /**\n     * YouTube Channel Constructor\n     * @param data YouTube Channel data that we recieve from basic info or from search\n     */\n    constructor(data: any = {}) {\n        if (!data) throw new Error(`Cannot instantiate the ${this.constructor.name} class without data!`);\n        this.type = 'channel';\n        this.name = data.name || null;\n        this.verified = !!data.verified || false;\n        this.artist = !!data.artist || false;\n        this.id = data.id || null;\n        this.url = data.url || null;\n        this.icons = data.icons || [{ url: null, width: 0, height: 0 }];\n        this.subscribers = data.subscribers || null;\n    }\n\n    /**\n     * Returns channel icon url\n     * @param {object} options Icon options\n     * @param {number} [options.size=0] Icon size. **Default is 0**\n     */\n    iconURL(options = { size: 0 }): string | undefined {\n        if (typeof options.size !== 'number' || options.size < 0) throw new Error('invalid icon size');\n        if (!this.icons?.[0]?.url) return undefined;\n        const def = this.icons?.[0]?.url.split('=s')[1].split('-c')[0];\n        return this.icons?.[0]?.url.replace(`=s${def}-c`, `=s${options.size}-c`);\n    }\n    /**\n     * Converts Channel Class to channel name.\n     * @returns name of channel\n     */\n    toString(): string {\n        return this.name || '';\n    }\n    /**\n     * Converts Channel Class to JSON format\n     * @returns json data of the channel\n     */\n    toJSON(): ChannelJSON {\n        return {\n            name: this.name,\n            verified: this.verified,\n            artist: this.artist,\n            id: this.id,\n            url: this.url,\n            icons: this.icons,\n            type: this.type,\n            subscribers: this.subscribers\n        };\n    }\n}\n\ninterface ChannelJSON {\n    /**\n     * YouTube Channel Title\n     */\n    name?: string;\n    /**\n     * YouTube Channel Verified status.\n     */\n    verified?: boolean;\n    /**\n     * YouTube Channel artist if any.\n     */\n    artist?: boolean;\n    /**\n     * YouTube Channel ID.\n     */\n    id?: string;\n    /**\n     * Type of Class [ Channel ]\n     */\n    type: 'video' | 'playlist' | 'channel';\n    /**\n     * YouTube Channel Url\n     */\n    url?: string;\n    /**\n     * YouTube Channel Icon data.\n     */\n    icons?: ChannelIconInterface[];\n    /**\n     * YouTube Channel subscribers count.\n     */\n    subscribers?: string;\n}\n","export class YouTubeThumbnail {\n    url: string;\n    width: number;\n    height: number;\n\n    constructor(data: any) {\n        this.url = data.url;\n        this.width = data.width;\n        this.height = data.height;\n    }\n\n    toJSON() {\n        return {\n            url: this.url,\n            width: this.width,\n            height: this.height\n        };\n    }\n}\n","import { YouTubeChannel } from './Channel';\nimport { YouTubeThumbnail } from './Thumbnail';\n\n/**\n * Licensed music in the video\n * \n * The property names change depending on your region's language.\n */\ninterface VideoMusic {\n    song?: string | MusicEntry;\n    artist?: string | MusicEntry;\n    album?: string;\n    writers?: string;\n    license?: string;\n}\n\ninterface MusicEntry {\n    text?: string;\n    url?: string;\n}\n\ninterface VideoOptions {\n    /**\n     * YouTube Video ID\n     */\n    id?: string;\n    /**\n     * YouTube video url\n     */\n    url: string;\n    /**\n     * YouTube Video title\n     */\n    title?: string;\n    /**\n     * YouTube Video description.\n     */\n    description?: string;\n    /**\n     * YouTube Video Duration Formatted\n     */\n    durationRaw: string;\n    /**\n     * YouTube Video Duration in seconds\n     */\n    durationInSec: number;\n    /**\n     * YouTube Video Uploaded Date\n     */\n    uploadedAt?: string;\n    /**\n     * If the video is upcoming or a premiere that isn't currently live, this will contain the premiere date, for watch page playlists this will be true, it defaults to undefined\n     */\n    upcoming?: Date | true;\n    /**\n     * YouTube Views\n     */\n    views: number;\n    /**\n     * YouTube Thumbnail Data\n     */\n    thumbnail?: {\n        width: number | undefined;\n        height: number | undefined;\n        url: string | undefined;\n    };\n    /**\n     * YouTube Video's uploader Channel Data\n     */\n    channel?: YouTubeChannel;\n    /**\n     * YouTube Video's likes\n     */\n    likes: number;\n    /**\n     * YouTube Video live status\n     */\n    live: boolean;\n    /**\n     * YouTube Video private status\n     */\n    private: boolean;\n    /**\n     * YouTube Video tags\n     */\n    tags: string[];\n    /**\n     * `true` if the video has been identified by the YouTube community as inappropriate or offensive to some audiences and viewer discretion is advised\n     */\n    discretionAdvised?: boolean;\n    /**\n     * Gives info about music content in that video.\n     * \n     * The property names of VideoMusic change depending on your region's language.\n     */\n    music?: VideoMusic[];\n    /**\n     * The chapters for this video\n     *\n     * If the video doesn't have any chapters or if the video object wasn't created by {@link video_basic_info} or {@link video_info} this will be an empty array.\n     */\n    chapters: VideoChapter[];\n}\n\nexport interface VideoChapter {\n    /**\n     * The title of the chapter\n     */\n    title: string;\n    /**\n     * The timestamp of the start of the chapter\n     */\n    timestamp: string;\n    /**\n     * The start of the chapter in seconds\n     */\n    seconds: number;\n    /**\n     * Thumbnails of the frame at the start of this chapter\n     */\n    thumbnails: YouTubeThumbnail[];\n}\n\n/**\n * Class for YouTube Video url\n */\nexport class YouTubeVideo {\n    /**\n     * YouTube Video ID\n     */\n    id?: string;\n    /**\n     * YouTube video url\n     */\n    url: string;\n    /**\n     * YouTube Class type. == \"video\"\n     */\n    type: 'video' | 'playlist' | 'channel';\n    /**\n     * YouTube Video title\n     */\n    title?: string;\n    /**\n     * YouTube Video description.\n     */\n    description?: string;\n    /**\n     * YouTube Video Duration Formatted\n     */\n    durationRaw: string;\n    /**\n     * YouTube Video Duration in seconds\n     */\n    durationInSec: number;\n    /**\n     * YouTube Video Uploaded Date\n     */\n    uploadedAt?: string;\n    /**\n     * YouTube Live Date\n     */\n    liveAt?: string;\n    /**\n     * If the video is upcoming or a premiere that isn't currently live, this will contain the premiere date, for watch page playlists this will be true, it defaults to undefined\n     */\n    upcoming?: Date | true;\n    /**\n     * YouTube Views\n     */\n    views: number;\n    /**\n     * YouTube Thumbnail Data\n     */\n    thumbnails: YouTubeThumbnail[];\n    /**\n     * YouTube Video's uploader Channel Data\n     */\n    channel?: YouTubeChannel;\n    /**\n     * YouTube Video's likes\n     */\n    likes: number;\n    /**\n     * YouTube Video live status\n     */\n    live: boolean;\n    /**\n     * YouTube Video private status\n     */\n    private: boolean;\n    /**\n     * YouTube Video tags\n     */\n    tags: string[];\n    /**\n     * `true` if the video has been identified by the YouTube community as inappropriate or offensive to some audiences and viewer discretion is advised\n     */\n    discretionAdvised?: boolean;\n    /**\n     * Gives info about music content in that video.\n     */\n    music?: VideoMusic[];\n    /**\n     * The chapters for this video\n     *\n     * If the video doesn't have any chapters or if the video object wasn't created by {@link video_basic_info} or {@link video_info} this will be an empty array.\n     */\n    chapters: VideoChapter[];\n    /**\n     * Constructor for YouTube Video Class\n     * @param data JSON parsed data.\n     */\n    constructor(data: any) {\n        if (!data) throw new Error(`Can not initiate ${this.constructor.name} without data`);\n\n        this.id = data.id || undefined;\n        this.url = `https://www.youtube.com/watch?v=${this.id}`;\n        this.type = 'video';\n        this.title = data.title || undefined;\n        this.description = data.description || undefined;\n        this.durationRaw = data.duration_raw || '0:00';\n        this.durationInSec = (data.duration < 0 ? 0 : data.duration) || 0;\n        this.uploadedAt = data.uploadedAt || undefined;\n        this.liveAt = data.liveAt || undefined;\n        this.upcoming = data.upcoming;\n        this.views = parseInt(data.views) || 0;\n        const thumbnails = [];\n        for (const thumb of data.thumbnails) {\n            thumbnails.push(new YouTubeThumbnail(thumb));\n        }\n        this.thumbnails = thumbnails || [];\n        this.channel = new YouTubeChannel(data.channel) || {};\n        this.likes = data.likes || 0;\n        this.live = !!data.live;\n        this.private = !!data.private;\n        this.tags = data.tags || [];\n        this.discretionAdvised = data.discretionAdvised ?? undefined;\n        this.music = data.music || [];\n        this.chapters = data.chapters || [];\n    }\n    /**\n     * Converts class to title name of video.\n     * @returns Title name\n     */\n    toString(): string {\n        return this.url || '';\n    }\n    /**\n     * Converts class to JSON data\n     * @returns JSON data.\n     */\n    toJSON(): VideoOptions {\n        return {\n            id: this.id,\n            url: this.url,\n            title: this.title,\n            description: this.description,\n            durationInSec: this.durationInSec,\n            durationRaw: this.durationRaw,\n            uploadedAt: this.uploadedAt,\n            thumbnail: this.thumbnails[this.thumbnails.length - 1].toJSON() || this.thumbnails,\n            channel: this.channel,\n            views: this.views,\n            tags: this.tags,\n            likes: this.likes,\n            live: this.live,\n            private: this.private,\n            discretionAdvised: this.discretionAdvised,\n            music: this.music,\n            chapters: this.chapters\n        };\n    }\n}\n","import { getPlaylistVideos, getContinuationToken } from '../utils/extractor';\nimport { request } from '../../Request';\nimport { YouTubeChannel } from './Channel';\nimport { YouTubeVideo } from './Video';\nimport { YouTubeThumbnail } from './Thumbnail';\nconst BASE_API = 'https://www.youtube.com/youtubei/v1/browse?key=';\n/**\n * YouTube Playlist Class containing vital informations about playlist.\n */\nexport class YouTubePlayList {\n    /**\n     * YouTube Playlist ID\n     */\n    id?: string;\n    /**\n     * YouTube Playlist Name\n     */\n    title?: string;\n    /**\n     * YouTube Class type. == \"playlist\"\n     */\n    type: 'video' | 'playlist' | 'channel';\n    /**\n     * Total no of videos in that playlist\n     */\n    videoCount?: number;\n    /**\n     * Time when playlist was last updated\n     */\n    lastUpdate?: string;\n    /**\n     * Total views of that playlist\n     */\n    views?: number;\n    /**\n     * YouTube Playlist url\n     */\n    url?: string;\n    /**\n     * YouTube Playlist url with starting video url.\n     */\n    link?: string;\n    /**\n     * YouTube Playlist channel data\n     */\n    channel?: YouTubeChannel;\n    /**\n     * YouTube Playlist thumbnail Data\n     */\n    thumbnail?: YouTubeThumbnail;\n    /**\n     * Videos array containing data of first 100 videos\n     */\n    private videos?: YouTubeVideo[];\n    /**\n     * Map contaning data of all fetched videos\n     */\n    private fetched_videos: Map<string, YouTubeVideo[]>;\n    /**\n     * Token containing API key, Token, ClientVersion.\n     */\n    private _continuation: {\n        api?: string;\n        token?: string;\n        clientVersion?: string;\n    } = {};\n    /**\n     * Total no of pages count.\n     */\n    private __count: number;\n    /**\n     * Constructor for YouTube Playlist Class\n     * @param data Json Parsed YouTube Playlist data\n     * @param searchResult If the data is from search or not\n     */\n    constructor(data: any, searchResult = false) {\n        if (!data) throw new Error(`Cannot instantiate the ${this.constructor.name} class without data!`);\n        this.__count = 0;\n        this.fetched_videos = new Map();\n        this.type = 'playlist';\n        if (searchResult) this.__patchSearch(data);\n        else this.__patch(data);\n    }\n    /**\n     * Updates variable according to a normal data.\n     * @param data Json Parsed YouTube Playlist data\n     */\n    private __patch(data: any) {\n        this.id = data.id || undefined;\n        this.url = data.url || undefined;\n        this.title = data.title || undefined;\n        this.videoCount = data.videoCount || 0;\n        this.lastUpdate = data.lastUpdate || undefined;\n        this.views = data.views || 0;\n        this.link = data.link || undefined;\n        this.channel = new YouTubeChannel(data.channel) || undefined;\n        this.thumbnail = data.thumbnail ? new YouTubeThumbnail(data.thumbnail) : undefined;\n        this.videos = data.videos || [];\n        this.__count++;\n        this.fetched_videos.set(`${this.__count}`, this.videos as YouTubeVideo[]);\n        this._continuation.api = data.continuation?.api ?? undefined;\n        this._continuation.token = data.continuation?.token ?? undefined;\n        this._continuation.clientVersion = data.continuation?.clientVersion ?? '<important data>';\n    }\n    /**\n     * Updates variable according to a searched data.\n     * @param data Json Parsed YouTube Playlist data\n     */\n    private __patchSearch(data: any) {\n        this.id = data.id || undefined;\n        this.url = this.id ? `https://www.youtube.com/playlist?list=${this.id}` : undefined;\n        this.title = data.title || undefined;\n        this.thumbnail = new YouTubeThumbnail(data.thumbnail) || undefined;\n        this.channel = data.channel || undefined;\n        this.videos = [];\n        this.videoCount = data.videos || 0;\n        this.link = undefined;\n        this.lastUpdate = undefined;\n        this.views = 0;\n    }\n    /**\n     * Parses next segment of videos from playlist and returns parsed data.\n     * @param limit Total no of videos to parse.\n     *\n     * Default = Infinity\n     * @returns Array of YouTube Video Class\n     */\n    async next(limit = Infinity): Promise<YouTubeVideo[]> {\n        if (!this._continuation || !this._continuation.token) return [];\n\n        const nextPage = await request(`${BASE_API}${this._continuation.api}&prettyPrint=false`, {\n            method: 'POST',\n            body: JSON.stringify({\n                continuation: this._continuation.token,\n                context: {\n                    client: {\n                        utcOffsetMinutes: 0,\n                        gl: 'US',\n                        hl: 'en',\n                        clientName: 'WEB',\n                        clientVersion: this._continuation.clientVersion\n                    },\n                    user: {},\n                    request: {}\n                }\n            })\n        });\n\n        const contents =\n            JSON.parse(nextPage)?.onResponseReceivedActions[0]?.appendContinuationItemsAction?.continuationItems;\n        if (!contents) return [];\n\n        const playlist_videos = getPlaylistVideos(contents, limit);\n        this.fetched_videos.set(`${this.__count}`, playlist_videos);\n        this._continuation.token = getContinuationToken(contents);\n        return playlist_videos;\n    }\n    /**\n     * Fetches remaining data from playlist\n     *\n     * For fetching and getting all songs data, see `total_pages` property.\n     * @param max Max no of videos to fetch\n     *\n     * Default = Infinity\n     * @returns\n     */\n    async fetch(max = Infinity): Promise<YouTubePlayList> {\n        const continuation = this._continuation.token;\n        if (!continuation) return this;\n        if (max < 1) max = Infinity;\n\n        while (typeof this._continuation.token === 'string' && this._continuation.token.length) {\n            this.__count++;\n            const res = await this.next();\n            max -= res.length;\n            if (max <= 0) break;\n            if (!res.length) break;\n        }\n\n        return this;\n    }\n    /**\n     * YouTube Playlists are divided into pages.\n     *\n     * For example, if you want to get 101 - 200 songs\n     *\n     * ```ts\n     * const playlist = await play.playlist_info('playlist url')\n     *\n     * await playlist.fetch()\n     *\n     * const result = playlist.page(2)\n     * ```\n     * @param number Page number\n     * @returns Array of YouTube Video Class\n     * @see {@link YouTubePlayList.all_videos}\n     */\n    page(number: number): YouTubeVideo[] {\n        if (!number) throw new Error('Page number is not provided');\n        if (!this.fetched_videos.has(`${number}`)) throw new Error('Given Page number is invalid');\n        return this.fetched_videos.get(`${number}`) as YouTubeVideo[];\n    }\n    /**\n     * Gets total number of pages in that playlist class.\n     * @see {@link YouTubePlayList.all_videos}\n     */\n    get total_pages() {\n        return this.fetched_videos.size;\n    }\n    /**\n     * This tells total number of videos that have been fetched so far.\n     *\n     * This can be equal to videosCount if all videos in playlist have been fetched and they are not hidden.\n     */\n    get total_videos() {\n        const page_number: number = this.total_pages;\n        return (page_number - 1) * 100 + (this.fetched_videos.get(`${page_number}`) as YouTubeVideo[]).length;\n    }\n    /**\n     * Fetches all the videos in the playlist and returns them\n     *\n     * ```ts\n     * const playlist = await play.playlist_info('playlist url')\n     *\n     * const videos = await playlist.all_videos()\n     * ```\n     * @returns An array of {@link YouTubeVideo} objects\n     * @see {@link YouTubePlayList.fetch}\n     */\n    async all_videos(): Promise<YouTubeVideo[]> {\n        await this.fetch();\n\n        const videos = [];\n\n        for (const page of this.fetched_videos.values()) videos.push(...page);\n\n        return videos;\n    }\n    /**\n     * Converts Playlist Class to a json parsed data.\n     * @returns\n     */\n    toJSON(): PlaylistJSON {\n        return {\n            id: this.id,\n            title: this.title,\n            thumbnail: this.thumbnail?.toJSON() || this.thumbnail,\n            channel: this.channel,\n            url: this.url,\n            videos: this.videos\n        };\n    }\n}\n\ninterface PlaylistJSON {\n    /**\n     * YouTube Playlist ID\n     */\n    id?: string;\n    /**\n     * YouTube Playlist Name\n     */\n    title?: string;\n    /**\n     * Total no of videos in that playlist\n     */\n    videoCount?: number;\n    /**\n     * Time when playlist was last updated\n     */\n    lastUpdate?: string;\n    /**\n     * Total views of that playlist\n     */\n    views?: number;\n    /**\n     * YouTube Playlist url\n     */\n    url?: string;\n    /**\n     * YouTube Playlist url with starting video url.\n     */\n    link?: string;\n    /**\n     * YouTube Playlist channel data\n     */\n    channel?: YouTubeChannel;\n    /**\n     * YouTube Playlist thumbnail Data\n     */\n    thumbnail?: {\n        width: number | undefined;\n        height: number | undefined;\n        url: string | undefined;\n    };\n    /**\n     * first 100 videos in that playlist\n     */\n    videos?: YouTubeVideo[];\n}\n","import { request } from './../../Request/index';\nimport { format_decipher } from './cipher';\nimport { VideoChapter, YouTubeVideo } from '../classes/Video';\nimport { YouTubePlayList } from '../classes/Playlist';\nimport { InfoData, StreamInfoData } from './constants';\nimport { URL, URLSearchParams } from 'node:url';\nimport { parseAudioFormats } from '../stream';\n\ninterface InfoOptions {\n    htmldata?: boolean;\n    language?: string;\n}\n\ninterface PlaylistOptions {\n    incomplete?: boolean;\n    language?: string;\n}\n\nconst video_id_pattern = /^[a-zA-Z\\d_-]{11,12}$/;\nconst playlist_id_pattern = /^(PL|UU|LL|RD|OL)[a-zA-Z\\d_-]{10,}$/;\nconst DEFAULT_API_KEY = 'AIzaSyAO_FJ2SlqU8Q4STEHLGCilw_Y9_11qcW8';\nconst video_pattern =\n    /^((?:https?:)?\\/\\/)?(?:(?:www|m|music)\\.)?((?:youtube\\.com|youtu.be))(\\/(?:[\\w\\-]+\\?v=|shorts\\/|embed\\/|v\\/)?)([\\w\\-]+)(\\S+)?$/;\nconst playlist_pattern =\n    /^((?:https?:)?\\/\\/)?(?:(?:www|m|music)\\.)?((?:youtube\\.com|youtu.be))\\/(?:(playlist|watch))?(.*)?((\\?|\\&)list=)(PL|UU|LL|RD|OL)[a-zA-Z\\d_-]{10,}(&.*)?$/;\n/**\n * Validate YouTube URL or ID.\n *\n * **CAUTION :** If your search word is 11 or 12 characters long, you might get it validated as video ID.\n *\n * To avoid above, add one more condition to yt_validate\n * ```ts\n * if (url.startsWith('https') && yt_validate(url) === 'video') {\n *      // YouTube Video Url.\n * }\n * ```\n * @param url YouTube URL OR ID\n * @returns\n * ```\n * 'playlist' | 'video' | 'search' | false\n * ```\n */\nexport function yt_validate(url: string): 'playlist' | 'video' | 'search' | false {\n    const url_ = url.trim();\n    if (url_.indexOf('list=') === -1) {\n        if (url_.startsWith('https')) {\n            if (url_.match(video_pattern)) {\n                let id: string;\n                if (url_.includes('youtu.be/')) id = url_.split('youtu.be/')[1].split(/(\\?|\\/|&)/)[0];\n                else if (url_.includes('youtube.com/embed/'))\n                    id = url_.split('youtube.com/embed/')[1].split(/(\\?|\\/|&)/)[0];\n                else if (url_.includes('youtube.com/shorts/'))\n                    id = url_.split('youtube.com/shorts/')[1].split(/(\\?|\\/|&)/)[0];\n                else id = url_.split('watch?v=')[1]?.split(/(\\?|\\/|&)/)[0];\n                if (id?.match(video_id_pattern)) return 'video';\n                else return false;\n            } else return false;\n        } else {\n            if (url_.match(video_id_pattern)) return 'video';\n            else if (url_.match(playlist_id_pattern)) return 'playlist';\n            else return 'search';\n        }\n    } else {\n        if (!url_.match(playlist_pattern)) return yt_validate(url_.replace(/(\\?|\\&)list=[^&]*/, ''));\n        else return 'playlist';\n    }\n}\n/**\n * Extracts the video ID from a YouTube URL.\n *\n * Will return the value of `urlOrId` if it looks like a video ID.\n * @param urlOrId A YouTube URL or video ID\n * @returns the video ID or `false` if it can't find a video ID.\n */\nfunction extractVideoId(urlOrId: string): string | false {\n    if (urlOrId.startsWith('https://') && urlOrId.match(video_pattern)) {\n        let id: string;\n        if (urlOrId.includes('youtu.be/')) {\n            id = urlOrId.split('youtu.be/')[1].split(/(\\?|\\/|&)/)[0];\n        } else if (urlOrId.includes('youtube.com/embed/')) {\n            id = urlOrId.split('youtube.com/embed/')[1].split(/(\\?|\\/|&)/)[0];\n        } else if (urlOrId.includes('youtube.com/shorts/')) {\n            id = urlOrId.split('youtube.com/shorts/')[1].split(/(\\?|\\/|&)/)[0];\n        } else {\n            id = (urlOrId.split('watch?v=')[1] ?? urlOrId.split('&v=')[1]).split(/(\\?|\\/|&)/)[0];\n        }\n\n        if (id.match(video_id_pattern)) return id;\n    } else if (urlOrId.match(video_id_pattern)) {\n        return urlOrId;\n    }\n\n    return false;\n}\n/**\n * Extract ID of YouTube url.\n * @param url ID or url of YouTube\n * @returns ID of video or playlist.\n */\nexport function extractID(url: string): string {\n    const check = yt_validate(url);\n    if (!check || check === 'search') throw new Error('This is not a YouTube url or videoId or PlaylistID');\n    const url_ = url.trim();\n    if (url_.startsWith('https')) {\n        if (url_.indexOf('list=') === -1) {\n            const video_id = extractVideoId(url_);\n            if (!video_id) throw new Error('This is not a YouTube url or videoId or PlaylistID');\n            return video_id;\n        } else {\n            return url_.split('list=')[1].split('&')[0];\n        }\n    } else return url_;\n}\n/**\n * Basic function to get data from a YouTube url or ID.\n *\n * Example\n * ```ts\n * const video = await play.video_basic_info('youtube video url')\n *\n * const res = ... // Any https package get function.\n *\n * const video = await play.video_basic_info(res.body, { htmldata : true })\n * ```\n * @param url YouTube url or ID or html body data\n * @param options Video Info Options\n *  - `boolean` htmldata : given data is html data or not\n * @returns Video Basic Info {@link InfoData}.\n */\nexport async function video_basic_info(url: string, options: InfoOptions = {}): Promise<InfoData> {\n    if (typeof url !== 'string') throw new Error('url parameter is not a URL string or a string of HTML');\n    const url_ = url.trim();\n    let body: string;\n    const cookieJar = {};\n    if (options.htmldata) {\n        body = url_;\n    } else {\n        const video_id = extractVideoId(url_);\n        if (!video_id) throw new Error('This is not a YouTube Watch URL');\n        const new_url = `https://www.youtube.com/watch?v=${video_id}&has_verified=1`;\n        body = await request(new_url, {\n            headers: {\n                'accept-language': options.language || 'en-US;q=0.9'\n            },\n            cookies: true,\n            cookieJar\n        });\n    }\n    if (body.indexOf('Our systems have detected unusual traffic from your computer network.') !== -1)\n        throw new Error('Captcha page: YouTube has detected that you are a bot!');\n    const player_data = body\n        .split('var ytInitialPlayerResponse = ')?.[1]\n        ?.split(';</script>')[0]\n        .split(/(?<=}}});\\s*(var|const|let)\\s/)[0];\n    if (!player_data) throw new Error('Initial Player Response Data is undefined.');\n    const initial_data = body\n        .split('var ytInitialData = ')?.[1]\n        ?.split(';</script>')[0]\n        .split(/;\\s*(var|const|let)\\s/)[0];\n    if (!initial_data) throw new Error('Initial Response Data is undefined.');\n    const player_response = JSON.parse(player_data);\n    const initial_response = JSON.parse(initial_data);\n    const vid = player_response.videoDetails;\n\n    let discretionAdvised = false;\n    let upcoming = false;\n    if (player_response.playabilityStatus.status !== 'OK') {\n        if (player_response.playabilityStatus.status === 'CONTENT_CHECK_REQUIRED') {\n            if (options.htmldata)\n                throw new Error(\n                    `Accepting the viewer discretion is not supported when using htmldata, video: ${vid.videoId}`\n                );\n            discretionAdvised = true;\n            const cookies =\n                initial_response.topbar.desktopTopbarRenderer.interstitial?.consentBumpV2Renderer.agreeButton\n                    .buttonRenderer.command.saveConsentAction;\n            if (cookies) {\n                Object.assign(cookieJar, {\n                    VISITOR_INFO1_LIVE: cookies.visitorCookie,\n                    CONSENT: cookies.consentCookie\n                });\n            }\n\n            const updatedValues = await acceptViewerDiscretion(vid.videoId, cookieJar, body, true);\n            player_response.streamingData = updatedValues.streamingData;\n            initial_response.contents.twoColumnWatchNextResults.secondaryResults = updatedValues.relatedVideos;\n        } else if (player_response.playabilityStatus.status === 'LIVE_STREAM_OFFLINE') upcoming = true;\n        else\n            throw new Error(\n                `While getting info from url\\n${\n                    player_response.playabilityStatus.errorScreen.playerErrorMessageRenderer?.reason.simpleText ??\n                    player_response.playabilityStatus.errorScreen.playerKavRenderer?.reason.simpleText ??\n                    player_response.playabilityStatus.reason\n                }`\n            );\n    }\n    const ownerInfo =\n        initial_response.contents.twoColumnWatchNextResults.results?.results?.contents[1]?.videoSecondaryInfoRenderer\n            ?.owner?.videoOwnerRenderer;\n    const badge = ownerInfo?.badges?.[0]?.metadataBadgeRenderer?.style?.toLowerCase();\n    const html5player = `https://www.youtube.com${body.split('\"jsUrl\":\"')[1].split('\"')[0]}`;\n    const related: string[] = [];\n    initial_response.contents.twoColumnWatchNextResults.secondaryResults.secondaryResults.results.forEach(\n        (res: any) => {\n            if (res.compactVideoRenderer)\n                related.push(`https://www.youtube.com/watch?v=${res.compactVideoRenderer.videoId}`);\n            if (res.itemSectionRenderer?.contents)\n                res.itemSectionRenderer.contents.forEach((x: any) => {\n                    if (x.compactVideoRenderer)\n                        related.push(`https://www.youtube.com/watch?v=${x.compactVideoRenderer.videoId}`);\n                });\n        }\n    );\n    const microformat = player_response.microformat.playerMicroformatRenderer;\n    const musicInfo =\n        initial_response.contents.twoColumnWatchNextResults.results.results.contents?.[1]?.videoSecondaryInfoRenderer\n            ?.metadataRowContainer?.metadataRowContainerRenderer?.rows;\n    const music: any[] = [];\n    if (musicInfo) {\n        musicInfo.forEach((x: any) => {\n            if (!x.metadataRowRenderer) return;\n            const row = x.metadataRowRenderer;\n\n            const title = row.title.simpleText ?? row.title.runs[0].text;\n            const contents = row.contents[0].simpleText ?? row.contents[0]?.runs?.[0]?.text;\n            const url = row.contents[0]?.runs?.[0]?.navigationEndpoint?.commandMetadata?.webCommandMetadata.url;\n\n            if (music.length === 0) music.push({});\n\n            music[music.length - 1][title.toLowerCase()] = url ? {text: contents, url: `https://www.youtube.com${url}`} : contents;\n\n            if (row.hasDividerLine) music.push({});\n        });\n    }\n    const rawChapters =\n        initial_response.playerOverlays.playerOverlayRenderer.decoratedPlayerBarRenderer?.decoratedPlayerBarRenderer.playerBar?.multiMarkersPlayerBarRenderer.markersMap.find(\n            (m: any) => m.key === 'DESCRIPTION_CHAPTERS'\n        )?.value?.chapters;\n    const chapters: VideoChapter[] = [];\n    if (rawChapters) {\n        for (const { chapterRenderer } of rawChapters) {\n            chapters.push({\n                title: chapterRenderer.title.simpleText,\n                timestamp: parseSeconds(chapterRenderer.timeRangeStartMillis / 1000),\n                seconds: chapterRenderer.timeRangeStartMillis / 1000,\n                thumbnails: chapterRenderer.thumbnail.thumbnails\n            });\n        }\n    }\n    let upcomingDate;\n    if (upcoming) {\n        if (microformat.liveBroadcastDetails.startTimestamp)\n            upcomingDate = new Date(microformat.liveBroadcastDetails.startTimestamp);\n        else {\n            const timestamp =\n                player_response.playabilityStatus.liveStreamability.liveStreamabilityRenderer.offlineSlate\n                    .liveStreamOfflineSlateRenderer.scheduledStartTime;\n            upcomingDate = new Date(parseInt(timestamp) * 1000);\n        }\n    }\n    const video_details = new YouTubeVideo({\n        id: vid.videoId,\n        title: vid.title,\n        description: vid.shortDescription,\n        duration: Number(vid.lengthSeconds),\n        duration_raw: parseSeconds(vid.lengthSeconds),\n        uploadedAt: microformat.publishDate,\n        liveAt: microformat.liveBroadcastDetails?.startTimestamp,\n        upcoming: upcomingDate,\n        thumbnails: vid.thumbnail.thumbnails,\n        channel: {\n            name: vid.author,\n            id: vid.channelId,\n            url: `https://www.youtube.com/channel/${vid.channelId}`,\n            verified: Boolean(badge?.includes('verified')),\n            artist: Boolean(badge?.includes('artist')),\n            icons: ownerInfo?.thumbnail?.thumbnails || undefined\n        },\n        views: vid.viewCount,\n        tags: vid.keywords,\n        likes: parseInt(\n            initial_response?.contents?.twoColumnWatchNextResults?.results?.results?.contents\n                ?.find?.((content: any) => content?.videoPrimaryInfoRenderer)\n                ?.videoPrimaryInfoRenderer?.videoActions?.menuRenderer?.topLevelButtons?.find(\n                    (button: any) => button?.toggleButtonRenderer?.defaultIcon?.iconType === 'LIKE'\n                )\n                ?.toggleButtonRenderer?.defaultText?.accessibility?.accessibilityData?.label?.replace?.(/\\D+/g, '') ?? 0\n        ),\n        live: vid.isLiveContent,\n        private: vid.isPrivate,\n        discretionAdvised,\n        music,\n        chapters\n    });\n    let format = [];\n    if (!upcoming) {\n        format.push(...(player_response.streamingData.formats ?? []));\n        format.push(...(player_response.streamingData.adaptiveFormats ?? []));\n\n        // get the formats for the android player for legacy videos\n        // fixes the stream being closed because not enough data\n        // arrived in time for ffmpeg to be able to extract audio data\n        if (parseAudioFormats(format).length === 0 && !options.htmldata) {\n            format = await getAndroidFormats(vid.videoId, cookieJar, body);\n        }\n    }\n    const LiveStreamData = {\n        isLive: video_details.live,\n        dashManifestUrl: player_response.streamingData?.dashManifestUrl ?? null,\n        hlsManifestUrl: player_response.streamingData?.hlsManifestUrl ?? null\n    };\n    return {\n        LiveStreamData,\n        html5player,\n        format,\n        video_details,\n        related_videos: related\n    };\n}\n/**\n * Gets the data required for streaming from YouTube url, ID or html body data and deciphers it.\n *\n * Internal function used by {@link stream} instead of {@link video_info}\n * because it only extracts the information required for streaming.\n *\n * @param url YouTube url or ID or html body data\n * @param options Video Info Options\n *  - `boolean` htmldata : given data is html data or not\n * @returns Deciphered Video Info {@link StreamInfoData}.\n */\nexport async function video_stream_info(url: string, options: InfoOptions = {}): Promise<StreamInfoData> {\n    if (typeof url !== 'string') throw new Error('url parameter is not a URL string or a string of HTML');\n    let body: string;\n    const cookieJar = {};\n    if (options.htmldata) {\n        body = url;\n    } else {\n        const video_id = extractVideoId(url);\n        if (!video_id) throw new Error('This is not a YouTube Watch URL');\n        const new_url = `https://www.youtube.com/watch?v=${video_id}&has_verified=1`;\n        body = await request(new_url, {\n            headers: { 'accept-language': 'en-US,en;q=0.9' },\n            cookies: true,\n            cookieJar\n        });\n    }\n    if (body.indexOf('Our systems have detected unusual traffic from your computer network.') !== -1)\n        throw new Error('Captcha page: YouTube has detected that you are a bot!');\n    const player_data = body\n        .split('var ytInitialPlayerResponse = ')?.[1]\n        ?.split(';</script>')[0]\n        .split(/(?<=}}});\\s*(var|const|let)\\s/)[0];\n    if (!player_data) throw new Error('Initial Player Response Data is undefined.');\n    const player_response = JSON.parse(player_data);\n    let upcoming = false;\n    if (player_response.playabilityStatus.status !== 'OK') {\n        if (player_response.playabilityStatus.status === 'CONTENT_CHECK_REQUIRED') {\n            if (options.htmldata)\n                throw new Error(\n                    `Accepting the viewer discretion is not supported when using htmldata, video: ${player_response.videoDetails.videoId}`\n                );\n\n            const initial_data = body\n                .split('var ytInitialData = ')?.[1]\n                ?.split(';</script>')[0]\n                .split(/;\\s*(var|const|let)\\s/)[0];\n            if (!initial_data) throw new Error('Initial Response Data is undefined.');\n\n            const cookies =\n                JSON.parse(initial_data).topbar.desktopTopbarRenderer.interstitial?.consentBumpV2Renderer.agreeButton\n                    .buttonRenderer.command.saveConsentAction;\n            if (cookies) {\n                Object.assign(cookieJar, {\n                    VISITOR_INFO1_LIVE: cookies.visitorCookie,\n                    CONSENT: cookies.consentCookie\n                });\n            }\n\n            const updatedValues = await acceptViewerDiscretion(\n                player_response.videoDetails.videoId,\n                cookieJar,\n                body,\n                false\n            );\n            player_response.streamingData = updatedValues.streamingData;\n        } else if (player_response.playabilityStatus.status === 'LIVE_STREAM_OFFLINE') upcoming = true;\n        else\n            throw new Error(\n                `While getting info from url\\n${\n                    player_response.playabilityStatus.errorScreen.playerErrorMessageRenderer?.reason.simpleText ??\n                    player_response.playabilityStatus.errorScreen.playerKavRenderer?.reason.simpleText ??\n                    player_response.playabilityStatus.reason\n                }`\n            );\n    }\n    const html5player = `https://www.youtube.com${body.split('\"jsUrl\":\"')[1].split('\"')[0]}`;\n    const duration = Number(player_response.videoDetails.lengthSeconds);\n    const video_details = {\n        url: `https://www.youtube.com/watch?v=${player_response.videoDetails.videoId}`,\n        durationInSec: (duration < 0 ? 0 : duration) || 0\n    };\n    let format = [];\n    if (!upcoming) {\n        format.push(...(player_response.streamingData.formats ?? []));\n        format.push(...(player_response.streamingData.adaptiveFormats ?? []));\n\n        // get the formats for the android player for legacy videos\n        // fixes the stream being closed because not enough data\n        // arrived in time for ffmpeg to be able to extract audio data\n        if (parseAudioFormats(format).length === 0 && !options.htmldata) {\n            format = await getAndroidFormats(player_response.videoDetails.videoId, cookieJar, body);\n        }\n    }\n\n    const LiveStreamData = {\n        isLive: player_response.videoDetails.isLiveContent,\n        dashManifestUrl: player_response.streamingData?.dashManifestUrl ?? null,\n        hlsManifestUrl: player_response.streamingData?.hlsManifestUrl ?? null\n    };\n    return await decipher_info(\n        {\n            LiveStreamData,\n            html5player,\n            format,\n            video_details\n        },\n        true\n    );\n}\n/**\n * Function to convert seconds to [hour : minutes : seconds] format\n * @param seconds seconds to convert\n * @returns [hour : minutes : seconds] format\n */\nfunction parseSeconds(seconds: number): string {\n    const d = Number(seconds);\n    const h = Math.floor(d / 3600);\n    const m = Math.floor((d % 3600) / 60);\n    const s = Math.floor((d % 3600) % 60);\n\n    const hDisplay = h > 0 ? (h < 10 ? `0${h}` : h) + ':' : '';\n    const mDisplay = m > 0 ? (m < 10 ? `0${m}` : m) + ':' : '00:';\n    const sDisplay = s > 0 ? (s < 10 ? `0${s}` : s) : '00';\n    return hDisplay + mDisplay + sDisplay;\n}\n/**\n * Gets data from YouTube url or ID or html body data and deciphers it.\n * ```\n * video_basic_info + decipher_info = video_info\n * ```\n *\n * Example\n * ```ts\n * const video = await play.video_info('youtube video url')\n *\n * const res = ... // Any https package get function.\n *\n * const video = await play.video_info(res.body, { htmldata : true })\n * ```\n * @param url YouTube url or ID or html body data\n * @param options Video Info Options\n *  - `boolean` htmldata : given data is html data or not\n * @returns Deciphered Video Info {@link InfoData}.\n */\nexport async function video_info(url: string, options: InfoOptions = {}): Promise<InfoData> {\n    const data = await video_basic_info(url.trim(), options);\n    return await decipher_info(data);\n}\n/**\n * Function uses data from video_basic_info and deciphers it if it contains signatures.\n * @param data Data - {@link InfoData}\n * @param audio_only `boolean` - To decipher only audio formats only.\n * @returns Deciphered Video Info {@link InfoData}\n */\nexport async function decipher_info<T extends InfoData | StreamInfoData>(\n    data: T,\n    audio_only: boolean = false\n): Promise<T> {\n    if (\n        data.LiveStreamData.isLive === true &&\n        data.LiveStreamData.dashManifestUrl !== null &&\n        data.video_details.durationInSec === 0\n    ) {\n        return data;\n    } else if (data.format.length > 0 && (data.format[0].signatureCipher || data.format[0].cipher)) {\n        if (audio_only) data.format = parseAudioFormats(data.format);\n        data.format = await format_decipher(data.format, data.html5player);\n        return data;\n    } else return data;\n}\n/**\n * Gets YouTube playlist info from a playlist url.\n *\n * Example\n * ```ts\n * const playlist = await play.playlist_info('youtube playlist url')\n *\n * const playlist = await play.playlist_info('youtube playlist url', { incomplete : true })\n * ```\n * @param url Playlist URL\n * @param options Playlist Info Options\n * - `boolean` incomplete : When this is set to `false` (default) this function will throw an error\n *                          if the playlist contains hidden videos.\n *                          If it is set to `true`, it parses the playlist skipping the hidden videos,\n *                          only visible videos are included in the resulting {@link YouTubePlaylist}.\n *\n * @returns YouTube Playlist\n */\nexport async function playlist_info(url: string, options: PlaylistOptions = {}): Promise<YouTubePlayList> {\n    if (!url || typeof url !== 'string') throw new Error(`Expected playlist url, received ${typeof url}!`);\n    let url_ = url.trim();\n    if (!url_.startsWith('https')) url_ = `https://www.youtube.com/playlist?list=${url_}`;\n    if (url_.indexOf('list=') === -1) throw new Error('This is not a Playlist URL');\n\n    if (url_.includes('music.youtube.com')) {\n        const urlObj = new URL(url_);\n        urlObj.hostname = 'www.youtube.com';\n        url_ = urlObj.toString();\n    }\n\n    const body = await request(url_, {\n        headers: {\n            'accept-language': options.language || 'en-US;q=0.9'\n        }\n    });\n    if (body.indexOf('Our systems have detected unusual traffic from your computer network.') !== -1)\n        throw new Error('Captcha page: YouTube has detected that you are a bot!');\n    const response = JSON.parse(\n        body\n            .split('var ytInitialData = ')[1]\n            .split(';</script>')[0]\n            .split(/;\\s*(var|const|let)\\s/)[0]\n    );\n    if (response.alerts) {\n        if (response.alerts[0].alertWithButtonRenderer?.type === 'INFO') {\n            if (!options.incomplete)\n                throw new Error(\n                    `While parsing playlist url\\n${response.alerts[0].alertWithButtonRenderer.text.simpleText}`\n                );\n        } else if (response.alerts[0].alertRenderer?.type === 'ERROR')\n            throw new Error(`While parsing playlist url\\n${response.alerts[0].alertRenderer.text.runs[0].text}`);\n        else throw new Error('While parsing playlist url\\nUnknown Playlist Error');\n    }\n    if (url_.indexOf('watch?v=') !== -1) {\n        return getWatchPlaylist(response, body, url_);\n    } else return getNormalPlaylist(response, body);\n}\n/**\n * Function to parse Playlist from YouTube search\n * @param data html data of that request\n * @param limit No. of videos to parse\n * @returns Array of YouTubeVideo.\n */\nexport function getPlaylistVideos(data: any, limit = Infinity): YouTubeVideo[] {\n    const videos = [];\n\n    for (let i = 0; i < data.length; i++) {\n        if (limit === videos.length) break;\n        const info = data[i].playlistVideoRenderer;\n        if (!info || !info.shortBylineText) continue;\n\n        videos.push(\n            new YouTubeVideo({\n                id: info.videoId,\n                duration: parseInt(info.lengthSeconds) || 0,\n                duration_raw: info.lengthText?.simpleText ?? '0:00',\n                thumbnails: info.thumbnail.thumbnails,\n                title: info.title.runs[0].text,\n                upcoming: info.upcomingEventData?.startTime\n                    ? new Date(parseInt(info.upcomingEventData.startTime) * 1000)\n                    : undefined,\n                channel: {\n                    id: info.shortBylineText.runs[0].navigationEndpoint.browseEndpoint.browseId || undefined,\n                    name: info.shortBylineText.runs[0].text || undefined,\n                    url: `https://www.youtube.com${\n                        info.shortBylineText.runs[0].navigationEndpoint.browseEndpoint.canonicalBaseUrl ||\n                        info.shortBylineText.runs[0].navigationEndpoint.commandMetadata.webCommandMetadata.url\n                    }`,\n                    icon: undefined\n                }\n            })\n        );\n    }\n    return videos;\n}\n/**\n * Function to get Continuation Token\n * @param data html data of playlist url\n * @returns token\n */\nexport function getContinuationToken(data: any): string {\n    return data.find((x: any) => Object.keys(x)[0] === 'continuationItemRenderer')?.continuationItemRenderer\n        .continuationEndpoint?.continuationCommand?.token;\n}\n\nasync function acceptViewerDiscretion(\n    videoId: string,\n    cookieJar: { [key: string]: string },\n    body: string,\n    extractRelated: boolean\n): Promise<{ streamingData: any; relatedVideos?: any }> {\n    const apiKey =\n        body.split('INNERTUBE_API_KEY\":\"')[1]?.split('\"')[0] ??\n        body.split('innertubeApiKey\":\"')[1]?.split('\"')[0] ??\n        DEFAULT_API_KEY;\n    const sessionToken =\n        body.split('\"XSRF_TOKEN\":\"')[1]?.split('\"')[0].replaceAll('\\\\u003d', '=') ??\n        body.split('\"xsrf_token\":\"')[1]?.split('\"')[0].replaceAll('\\\\u003d', '=');\n    if (!sessionToken)\n        throw new Error(`Unable to extract XSRF_TOKEN to accept the viewer discretion popup for video: ${videoId}.`);\n\n    const verificationResponse = await request(`https://www.youtube.com/youtubei/v1/verify_age?key=${apiKey}&prettyPrint=false`, {\n        method: 'POST',\n        body: JSON.stringify({\n            context: {\n                client: {\n                    utcOffsetMinutes: 0,\n                    gl: 'US',\n                    hl: 'en',\n                    clientName: 'WEB',\n                    clientVersion:\n                        body.split('\"INNERTUBE_CONTEXT_CLIENT_VERSION\":\"')[1]?.split('\"')[0] ??\n                        body.split('\"innertube_context_client_version\":\"')[1]?.split('\"')[0] ??\n                        '<some version>'\n                },\n                user: {},\n                request: {}\n            },\n            nextEndpoint: {\n                urlEndpoint: {\n                    url: `watch?v=${videoId}`\n                }\n            },\n            setControvercy: true\n        }),\n        cookies: true,\n        cookieJar\n    });\n\n    const endpoint = JSON.parse(verificationResponse).actions[0].navigateAction.endpoint;\n\n    const videoPage = await request(`https://www.youtube.com/${endpoint.urlEndpoint.url}&pbj=1`, {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/x-www-form-urlencoded'\n        },\n        body: new URLSearchParams([\n            ['command', JSON.stringify(endpoint)],\n            ['session_token', sessionToken]\n        ]).toString(),\n        cookies: true,\n        cookieJar\n    });\n\n    if (videoPage.includes('<h1>Something went wrong</h1>'))\n        throw new Error(`Unable to accept the viewer discretion popup for video: ${videoId}`);\n\n    const videoPageData = JSON.parse(videoPage);\n\n    if (videoPageData[2].playerResponse.playabilityStatus.status !== 'OK')\n        throw new Error(\n            `While getting info from url after trying to accept the discretion popup for video ${videoId}\\n${\n                videoPageData[2].playerResponse.playabilityStatus.errorScreen.playerErrorMessageRenderer?.reason\n                    .simpleText ??\n                videoPageData[2].playerResponse.playabilityStatus.errorScreen.playerKavRenderer?.reason.simpleText\n            }`\n        );\n\n    const streamingData = videoPageData[2].playerResponse.streamingData;\n\n    if (extractRelated)\n        return {\n            streamingData,\n            relatedVideos: videoPageData[3].response.contents.twoColumnWatchNextResults.secondaryResults\n        };\n\n    return { streamingData };\n}\n\nasync function getAndroidFormats(videoId: string, cookieJar: { [key: string]: string }, body: string): Promise<any[]> {\n    const apiKey =\n        body.split('INNERTUBE_API_KEY\":\"')[1]?.split('\"')[0] ??\n        body.split('innertubeApiKey\":\"')[1]?.split('\"')[0] ??\n        DEFAULT_API_KEY;\n\n    const response = await request(`https://www.youtube.com/youtubei/v1/player?key=${apiKey}&prettyPrint=false`, {\n        method: 'POST',\n        body: JSON.stringify({\n            context: {\n                client: {\n                    clientName: 'ANDROID',\n                    clientVersion: '16.49',\n                    hl: 'en',\n                    timeZone: 'UTC',\n                    utcOffsetMinutes: 0\n                }\n            },\n            videoId: videoId,\n            playbackContext: { contentPlaybackContext: { html5Preference: 'HTML5_PREF_WANTS' } },\n            contentCheckOk: true,\n            racyCheckOk: true\n        }),\n        cookies: true,\n        cookieJar\n    });\n\n    return JSON.parse(response).streamingData.formats;\n}\n\nfunction getWatchPlaylist(response: any, body: any, url: string): YouTubePlayList {\n    const playlist_details = response.contents.twoColumnWatchNextResults.playlist?.playlist;\n    if (!playlist_details)\n        throw new Error(\"Watch playlist unavailable due to YouTube layout changes.\")\n\n    const videos = getWatchPlaylistVideos(playlist_details.contents);\n    const API_KEY =\n        body.split('INNERTUBE_API_KEY\":\"')[1]?.split('\"')[0] ??\n        body.split('innertubeApiKey\":\"')[1]?.split('\"')[0] ??\n        DEFAULT_API_KEY;\n\n    const videoCount = playlist_details.totalVideos;\n    const channel = playlist_details.shortBylineText?.runs?.[0];\n    const badge = playlist_details.badges?.[0]?.metadataBadgeRenderer?.style.toLowerCase();\n\n    return new YouTubePlayList({\n        continuation: {\n            api: API_KEY,\n            token: getContinuationToken(playlist_details.contents),\n            clientVersion:\n                body.split('\"INNERTUBE_CONTEXT_CLIENT_VERSION\":\"')[1]?.split('\"')[0] ??\n                body.split('\"innertube_context_client_version\":\"')[1]?.split('\"')[0] ??\n                '<some version>'\n        },\n        id: playlist_details.playlistId || '',\n        title: playlist_details.title || '',\n        videoCount: parseInt(videoCount) || 0,\n        videos: videos,\n        url: url,\n        channel: {\n            id: channel?.navigationEndpoint?.browseEndpoint?.browseId || null,\n            name: channel?.text || null,\n            url: `https://www.youtube.com${\n                channel?.navigationEndpoint?.browseEndpoint?.canonicalBaseUrl ||\n                channel?.navigationEndpoint?.commandMetadata?.webCommandMetadata?.url\n            }`,\n            verified: Boolean(badge?.includes('verified')),\n            artist: Boolean(badge?.includes('artist'))\n        }\n    });\n}\n\nfunction getNormalPlaylist(response: any, body: any): YouTubePlayList {\n    const json_data =\n        response.contents.twoColumnBrowseResultsRenderer.tabs[0].tabRenderer.content.sectionListRenderer.contents[0]\n            .itemSectionRenderer.contents[0].playlistVideoListRenderer.contents;\n    const playlist_details = response.sidebar.playlistSidebarRenderer.items;\n\n    const API_KEY =\n        body.split('INNERTUBE_API_KEY\":\"')[1]?.split('\"')[0] ??\n        body.split('innertubeApiKey\":\"')[1]?.split('\"')[0] ??\n        DEFAULT_API_KEY;\n    const videos = getPlaylistVideos(json_data, 100);\n\n    const data = playlist_details[0].playlistSidebarPrimaryInfoRenderer;\n    if (!data.title.runs || !data.title.runs.length) throw new Error('Failed to Parse Playlist info.');\n\n    const author = playlist_details[1]?.playlistSidebarSecondaryInfoRenderer.videoOwner;\n    const views = data.stats.length === 3 ? data.stats[1].simpleText.replace(/\\D/g, '') : 0;\n    const lastUpdate =\n        data.stats\n            .find((x: any) => 'runs' in x && x['runs'].find((y: any) => y.text.toLowerCase().includes('last update')))\n            ?.runs.pop()?.text ?? null;\n    const videosCount = data.stats[0].runs[0].text.replace(/\\D/g, '') || 0;\n\n    const res = new YouTubePlayList({\n        continuation: {\n            api: API_KEY,\n            token: getContinuationToken(json_data),\n            clientVersion:\n                body.split('\"INNERTUBE_CONTEXT_CLIENT_VERSION\":\"')[1]?.split('\"')[0] ??\n                body.split('\"innertube_context_client_version\":\"')[1]?.split('\"')[0] ??\n                '<some version>'\n        },\n        id: data.title.runs[0].navigationEndpoint.watchEndpoint.playlistId,\n        title: data.title.runs[0].text,\n        videoCount: parseInt(videosCount) || 0,\n        lastUpdate: lastUpdate,\n        views: parseInt(views) || 0,\n        videos: videos,\n        url: `https://www.youtube.com/playlist?list=${data.title.runs[0].navigationEndpoint.watchEndpoint.playlistId}`,\n        link: `https://www.youtube.com${data.title.runs[0].navigationEndpoint.commandMetadata.webCommandMetadata.url}`,\n        channel: author\n            ? {\n                  name: author.videoOwnerRenderer.title.runs[0].text,\n                  id: author.videoOwnerRenderer.title.runs[0].navigationEndpoint.browseEndpoint.browseId,\n                  url: `https://www.youtube.com${\n                      author.videoOwnerRenderer.navigationEndpoint.commandMetadata.webCommandMetadata.url ||\n                      author.videoOwnerRenderer.navigationEndpoint.browseEndpoint.canonicalBaseUrl\n                  }`,\n                  icons: author.videoOwnerRenderer.thumbnail.thumbnails ?? []\n              }\n            : {},\n        thumbnail: data.thumbnailRenderer.playlistVideoThumbnailRenderer?.thumbnail.thumbnails.length\n            ? data.thumbnailRenderer.playlistVideoThumbnailRenderer.thumbnail.thumbnails[\n                  data.thumbnailRenderer.playlistVideoThumbnailRenderer.thumbnail.thumbnails.length - 1\n              ]\n            : null\n    });\n    return res;\n}\n\nfunction getWatchPlaylistVideos(data: any, limit = Infinity): YouTubeVideo[] {\n    const videos: YouTubeVideo[] = [];\n\n    for (let i = 0; i < data.length; i++) {\n        if (limit === videos.length) break;\n        const info = data[i].playlistPanelVideoRenderer;\n        if (!info || !info.shortBylineText) continue;\n        const channel_info = info.shortBylineText.runs[0];\n\n        videos.push(\n            new YouTubeVideo({\n                id: info.videoId,\n                duration: parseDuration(info.lengthText?.simpleText) || 0,\n                duration_raw: info.lengthText?.simpleText ?? '0:00',\n                thumbnails: info.thumbnail.thumbnails,\n                title: info.title.simpleText,\n                upcoming:\n                    info.thumbnailOverlays[0].thumbnailOverlayTimeStatusRenderer?.style === 'UPCOMING' || undefined,\n                channel: {\n                    id: channel_info.navigationEndpoint.browseEndpoint.browseId || undefined,\n                    name: channel_info.text || undefined,\n                    url: `https://www.youtube.com${\n                        channel_info.navigationEndpoint.browseEndpoint.canonicalBaseUrl ||\n                        channel_info.navigationEndpoint.commandMetadata.webCommandMetadata.url\n                    }`,\n                    icon: undefined\n                }\n            })\n        );\n    }\n\n    return videos;\n}\n\nfunction parseDuration(text: string): number {\n    if (!text) return 0;\n    const split = text.split(':');\n\n    switch (split.length) {\n        case 2:\n            return parseInt(split[0]) * 60 + parseInt(split[1]);\n\n        case 3:\n            return parseInt(split[0]) * 60 * 60 + parseInt(split[1]) * 60 + parseInt(split[2]);\n\n        default:\n            return 0;\n    }\n}","import { WebmElements, WebmHeader } from 'play-audio';\nimport { Duplex, DuplexOptions } from 'node:stream';\n\nenum DataType {\n    master,\n    string,\n    uint,\n    binary,\n    float\n}\n\nexport enum WebmSeekerState {\n    READING_HEAD = 'READING_HEAD',\n    READING_DATA = 'READING_DATA'\n}\n\ninterface WebmSeekerOptions extends DuplexOptions {\n    mode?: 'precise' | 'granular';\n}\n\nconst WEB_ELEMENT_KEYS = Object.keys(WebmElements);\n\nexport class WebmSeeker extends Duplex {\n    remaining?: Buffer;\n    state: WebmSeekerState;\n    chunk?: Buffer;\n    cursor: number;\n    header: WebmHeader;\n    headfound: boolean;\n    headerparsed: boolean;\n    seekfound: boolean;\n    private data_size: number;\n    private offset: number;\n    private data_length: number;\n    private sec: number;\n    private time: number;\n\n    constructor(sec: number, options: WebmSeekerOptions) {\n        super(options);\n        this.state = WebmSeekerState.READING_HEAD;\n        this.cursor = 0;\n        this.header = new WebmHeader();\n        this.headfound = false;\n        this.headerparsed = false;\n        this.seekfound = false;\n        this.data_length = 0;\n        this.data_size = 0;\n        this.offset = 0;\n        this.sec = sec;\n        this.time = Math.floor(sec / 10) * 10;\n    }\n\n    private get vint_length(): number {\n        let i = 0;\n        for (; i < 8; i++) {\n            if ((1 << (7 - i)) & this.chunk![this.cursor]) break;\n        }\n        return ++i;\n    }\n\n    private vint_value(): boolean {\n        if (!this.chunk) return false;\n        const length = this.vint_length;\n        if (this.chunk.length < this.cursor + length) return false;\n        let value = this.chunk[this.cursor] & ((1 << (8 - length)) - 1);\n        for (let i = this.cursor + 1; i < this.cursor + length; i++) value = (value << 8) + this.chunk[i];\n        this.data_size = length;\n        this.data_length = value;\n        return true;\n    }\n\n    cleanup() {\n        this.cursor = 0;\n        this.chunk = undefined;\n        this.remaining = undefined;\n    }\n\n    _read() {}\n\n    seek(content_length: number): Error | number {\n        let clusterlength = 0,\n            position = 0;\n        let time_left = (this.sec - this.time) * 1000 || 0;\n        time_left = Math.round(time_left / 20) * 20;\n        if (!this.header.segment.cues) return new Error('Failed to Parse Cues');\n\n        for (let i = 0; i < this.header.segment.cues.length; i++) {\n            const data = this.header.segment.cues[i];\n            if (Math.floor((data.time as number) / 1000) === this.time) {\n                position = data.position as number;\n                clusterlength = (this.header.segment.cues[i + 1]?.position || content_length) - position - 1;\n                break;\n            } else continue;\n        }\n        if (clusterlength === 0) return position;\n        return this.offset + Math.round(position + (time_left / 20) * (clusterlength / 500));\n    }\n\n    _write(chunk: Buffer, _: BufferEncoding, callback: (error?: Error | null) => void): void {\n        if (this.remaining) {\n            this.chunk = Buffer.concat([this.remaining, chunk]);\n            this.remaining = undefined;\n        } else this.chunk = chunk;\n\n        let err: Error | undefined;\n\n        if (this.state === WebmSeekerState.READING_HEAD) err = this.readHead();\n        else if (!this.seekfound) err = this.getClosestBlock();\n        else err = this.readTag();\n\n        if (err) callback(err);\n        else callback();\n    }\n\n    private readHead(): Error | undefined {\n        if (!this.chunk) return new Error('Chunk is missing');\n\n        while (this.chunk.length > this.cursor) {\n            const oldCursor = this.cursor;\n            const id = this.vint_length;\n            if (this.chunk.length < this.cursor + id) break;\n\n            const ebmlID = this.parseEbmlID(this.chunk.slice(this.cursor, this.cursor + id).toString('hex'));\n            this.cursor += id;\n\n            if (!this.vint_value()) {\n                this.cursor = oldCursor;\n                break;\n            }\n            if (!ebmlID) {\n                this.cursor += this.data_size + this.data_length;\n                continue;\n            }\n\n            if (!this.headfound) {\n                if (ebmlID.name === 'ebml') this.headfound = true;\n                else return new Error('Failed to find EBML ID at start of stream.');\n            }\n            const data = this.chunk.slice(\n                this.cursor + this.data_size,\n                this.cursor + this.data_size + this.data_length\n            );\n            const parse = this.header.parse(ebmlID, data);\n            if (parse instanceof Error) return parse;\n\n            // stop parsing the header once we have found the correct cue\n\n            if (ebmlID.name === 'seekHead') this.offset = oldCursor;\n\n            if (\n                ebmlID.name === 'cueClusterPosition' &&\n                this.header.segment.cues!.length > 2 &&\n                this.time === (this.header.segment.cues!.at(-2)!.time as number) / 1000\n            )\n                this.emit('headComplete');\n\n            if (ebmlID.type === DataType.master) {\n                this.cursor += this.data_size;\n                continue;\n            }\n\n            if (this.chunk.length < this.cursor + this.data_size + this.data_length) {\n                this.cursor = oldCursor;\n                break;\n            } else this.cursor += this.data_size + this.data_length;\n        }\n        this.remaining = this.chunk.slice(this.cursor);\n        this.cursor = 0;\n    }\n\n    private readTag(): Error | undefined {\n        if (!this.chunk) return new Error('Chunk is missing');\n\n        while (this.chunk.length > this.cursor) {\n            const oldCursor = this.cursor;\n            const id = this.vint_length;\n            if (this.chunk.length < this.cursor + id) break;\n\n            const ebmlID = this.parseEbmlID(this.chunk.slice(this.cursor, this.cursor + id).toString('hex'));\n            this.cursor += id;\n\n            if (!this.vint_value()) {\n                this.cursor = oldCursor;\n                break;\n            }\n            if (!ebmlID) {\n                this.cursor += this.data_size + this.data_length;\n                continue;\n            }\n\n            const data = this.chunk.slice(\n                this.cursor + this.data_size,\n                this.cursor + this.data_size + this.data_length\n            );\n            const parse = this.header.parse(ebmlID, data);\n            if (parse instanceof Error) return parse;\n\n            if (ebmlID.type === DataType.master) {\n                this.cursor += this.data_size;\n                continue;\n            }\n\n            if (this.chunk.length < this.cursor + this.data_size + this.data_length) {\n                this.cursor = oldCursor;\n                break;\n            } else this.cursor += this.data_size + this.data_length;\n\n            if (ebmlID.name === 'simpleBlock') {\n                const track = this.header.segment.tracks![this.header.audioTrack];\n                if (!track || track.trackType !== 2) return new Error('No audio Track in this webm file.');\n                if ((data[0] & 0xf) === track.trackNumber) this.push(data.slice(4));\n            }\n        }\n        this.remaining = this.chunk.slice(this.cursor);\n        this.cursor = 0;\n    }\n\n    private getClosestBlock(): Error | undefined {\n        if (this.sec === 0) {\n            this.seekfound = true;\n            return this.readTag();\n        }\n        if (!this.chunk) return new Error('Chunk is missing');\n        this.cursor = 0;\n        let positionFound = false;\n        while (!positionFound && this.cursor < this.chunk.length) {\n            this.cursor = this.chunk.indexOf('a3', this.cursor, 'hex');\n            if (this.cursor === -1) return new Error('Failed to find nearest Block.');\n            this.cursor++;\n            if (!this.vint_value()) return new Error('Failed to find correct simpleBlock in first chunk');\n            if (this.cursor + this.data_length + this.data_length > this.chunk.length) continue;\n            const data = this.chunk.slice(\n                this.cursor + this.data_size,\n                this.cursor + this.data_size + this.data_length\n            );\n            const track = this.header.segment.tracks![this.header.audioTrack];\n            if (!track || track.trackType !== 2) return new Error('No audio Track in this webm file.');\n            if ((data[0] & 0xf) === track.trackNumber) {\n                this.cursor += this.data_size + this.data_length;\n                this.push(data.slice(4));\n                positionFound = true;\n            } else continue;\n        }\n        if (!positionFound) return new Error('Failed to find nearest correct simple Block.');\n        this.seekfound = true;\n        return this.readTag();\n    }\n\n    private parseEbmlID(ebmlID: string) {\n        if (WEB_ELEMENT_KEYS.includes(ebmlID)) return WebmElements[ebmlID];\n        else return false;\n    }\n\n    _destroy(error: Error | null, callback: (error: Error | null) => void): void {\n        this.cleanup();\n        callback(error);\n    }\n\n    _final(callback: (error?: Error | null) => void): void {\n        this.cleanup();\n        callback();\n    }\n}\n","import { IncomingMessage } from 'node:http';\nimport { request_stream } from '../../Request';\nimport { parseAudioFormats, StreamOptions, StreamType } from '../stream';\nimport { video_stream_info } from '../utils/extractor';\nimport { Timer } from './LiveStream';\nimport { WebmSeeker, WebmSeekerState } from './WebmSeeker';\n\n/**\n * YouTube Stream Class for seeking audio to a timeStamp.\n */\nexport class SeekStream {\n    /**\n     * WebmSeeker Stream through which data passes\n     */\n    stream: WebmSeeker;\n    /**\n     * Type of audio data that we recieved from normal youtube url.\n     */\n    type: StreamType;\n    /**\n     * Audio Endpoint Format Url to get data from.\n     */\n    private url: string;\n    /**\n     * Used to calculate no of bytes data that we have recieved\n     */\n    private bytes_count: number;\n    /**\n     * Calculate per second bytes by using contentLength (Total bytes) / Duration (in seconds)\n     */\n    private per_sec_bytes: number;\n    /**\n     * Length of the header in bytes\n     */\n    private header_length: number;\n    /**\n     * Total length of audio file in bytes\n     */\n    private content_length: number;\n    /**\n     * YouTube video url. [ Used only for retrying purposes only. ]\n     */\n    private video_url: string;\n    /**\n     * Timer for looping data every 265 seconds.\n     */\n    private timer: Timer;\n    /**\n     * Quality given by user. [ Used only for retrying purposes only. ]\n     */\n    private quality: number;\n    /**\n     * Incoming message that we recieve.\n     *\n     * Storing this is essential.\n     * This helps to destroy the TCP connection completely if you stopped player in between the stream\n     */\n    private request: IncomingMessage | null;\n    /**\n     * YouTube Stream Class constructor\n     * @param url Audio Endpoint url.\n     * @param type Type of Stream\n     * @param duration Duration of audio playback [ in seconds ]\n     * @param headerLength Length of the header in bytes.\n     * @param contentLength Total length of Audio file in bytes.\n     * @param bitrate Bitrate provided by YouTube.\n     * @param video_url YouTube video url.\n     * @param options Options provided to stream function.\n     */\n    constructor(\n        url: string,\n        duration: number,\n        headerLength: number,\n        contentLength: number,\n        bitrate: number,\n        video_url: string,\n        options: StreamOptions\n    ) {\n        this.stream = new WebmSeeker(options.seek!, {\n            highWaterMark: 5 * 1000 * 1000,\n            readableObjectMode: true\n        });\n        this.url = url;\n        this.quality = options.quality as number;\n        this.type = StreamType.Opus;\n        this.bytes_count = 0;\n        this.video_url = video_url;\n        this.per_sec_bytes = bitrate ? Math.ceil(bitrate / 8) : Math.ceil(contentLength / duration);\n        this.header_length = headerLength;\n        this.content_length = contentLength;\n        this.request = null;\n        this.timer = new Timer(() => {\n            this.timer.reuse();\n            this.loop();\n        }, 265);\n        this.stream.on('close', () => {\n            this.timer.destroy();\n            this.cleanup();\n        });\n        this.seek();\n    }\n    /**\n     * **INTERNAL Function**\n     *\n     * Uses stream functions to parse Webm Head and gets Offset byte to seek to.\n     * @returns Nothing\n     */\n    private async seek(): Promise<void> {\n        const parse = await new Promise(async (res, rej) => {\n            if (!this.stream.headerparsed) {\n                const stream = await request_stream(this.url, {\n                    headers: {\n                        range: `bytes=0-${this.header_length}`\n                    }\n                }).catch((err: Error) => err);\n\n                if (stream instanceof Error) {\n                    rej(stream);\n                    return;\n                }\n                if (Number(stream.statusCode) >= 400) {\n                    rej(400);\n                    return;\n                }\n                this.request = stream;\n                stream.pipe(this.stream, { end: false });\n\n                // headComplete should always be called, leaving this here just in case\n                stream.once('end', () => {\n                    this.stream.state = WebmSeekerState.READING_DATA;\n                    res('');\n                });\n\n                this.stream.once('headComplete', () => {\n                    stream.unpipe(this.stream);\n                    stream.destroy();\n                    this.stream.state = WebmSeekerState.READING_DATA;\n                    res('');\n                });\n            } else res('');\n        }).catch((err) => err);\n        if (parse instanceof Error) {\n            this.stream.emit('error', parse);\n            this.bytes_count = 0;\n            this.per_sec_bytes = 0;\n            this.cleanup();\n            return;\n        } else if (parse === 400) {\n            await this.retry();\n            this.timer.reuse();\n            return this.seek();\n        }\n        const bytes = this.stream.seek(this.content_length);\n        if (bytes instanceof Error) {\n            this.stream.emit('error', bytes);\n            this.bytes_count = 0;\n            this.per_sec_bytes = 0;\n            this.cleanup();\n            return;\n        }\n\n        this.stream.seekfound = false;\n        this.bytes_count = bytes;\n        this.timer.reuse();\n        this.loop();\n    }\n    /**\n     * Retry if we get 404 or 403 Errors.\n     */\n    private async retry() {\n        const info = await video_stream_info(this.video_url);\n        const audioFormat = parseAudioFormats(info.format);\n        this.url = audioFormat[this.quality].url;\n    }\n    /**\n     * This cleans every used variable in class.\n     *\n     * This is used to prevent re-use of this class and helping garbage collector to collect it.\n     */\n    private cleanup() {\n        this.request?.destroy();\n        this.request = null;\n        this.url = '';\n    }\n    /**\n     * Getting data from audio endpoint url and passing it to stream.\n     *\n     * If 404 or 403 occurs, it will retry again.\n     */\n    private async loop() {\n        if (this.stream.destroyed) {\n            this.timer.destroy();\n            this.cleanup();\n            return;\n        }\n        const end: number = this.bytes_count + this.per_sec_bytes * 300;\n        const stream = await request_stream(this.url, {\n            headers: {\n                range: `bytes=${this.bytes_count}-${end >= this.content_length ? '' : end}`\n            }\n        }).catch((err: Error) => err);\n        if (stream instanceof Error) {\n            this.stream.emit('error', stream);\n            this.bytes_count = 0;\n            this.per_sec_bytes = 0;\n            this.cleanup();\n            return;\n        }\n        if (Number(stream.statusCode) >= 400) {\n            this.cleanup();\n            await this.retry();\n            this.timer.reuse();\n            this.loop();\n            return;\n        }\n        this.request = stream;\n        stream.pipe(this.stream, { end: false });\n\n        stream.once('error', async () => {\n            this.cleanup();\n            await this.retry();\n            this.timer.reuse();\n            this.loop();\n        });\n\n        stream.on('data', (chunk: any) => {\n            this.bytes_count += chunk.length;\n        });\n\n        stream.on('end', () => {\n            if (end >= this.content_length) {\n                this.timer.destroy();\n                this.stream.end();\n                this.cleanup();\n            }\n        });\n    }\n    /**\n     * Pauses timer.\n     * Stops running of loop.\n     *\n     * Useful if you don't want to get excess data to be stored in stream.\n     */\n    pause() {\n        this.timer.pause();\n    }\n    /**\n     * Resumes timer.\n     * Starts running of loop.\n     */\n    resume() {\n        this.timer.resume();\n    }\n}\n","import { request_content_length, request_stream } from '../Request';\nimport { LiveStream, Stream } from './classes/LiveStream';\nimport { SeekStream } from './classes/SeekStream';\nimport { InfoData, StreamInfoData } from './utils/constants';\nimport { video_stream_info } from './utils/extractor';\nimport { URL } from 'node:url';\n\nexport enum StreamType {\n    Arbitrary = 'arbitrary',\n    Raw = 'raw',\n    OggOpus = 'ogg/opus',\n    WebmOpus = 'webm/opus',\n    Opus = 'opus'\n}\n\nexport interface StreamOptions {\n    seek?: number;\n    quality?: number;\n    language?: string;\n    htmldata?: boolean;\n    precache?: number;\n    discordPlayerCompatibility?: boolean;\n}\n\n/**\n * Command to find audio formats from given format array\n * @param formats Formats to search from\n * @returns Audio Formats array\n */\nexport function parseAudioFormats(formats: any[]) {\n    const result: any[] = [];\n    formats.forEach((format) => {\n        const type = format.mimeType as string;\n        if (type.startsWith('audio')) {\n            format.codec = type.split('codecs=\"')[1].split('\"')[0];\n            format.container = type.split('audio/')[1].split(';')[0];\n            result.push(format);\n        }\n    });\n    return result;\n}\n/**\n * Type for YouTube Stream\n */\nexport type YouTubeStream = Stream | LiveStream | SeekStream;\n/**\n * Stream command for YouTube\n * @param url YouTube URL\n * @param options lets you add quality for stream\n * @returns Stream class with type and stream for playing.\n */\nexport async function stream(url: string, options: StreamOptions = {}): Promise<YouTubeStream> {\n    const info = await video_stream_info(url, { htmldata: options.htmldata, language: options.language });\n    return await stream_from_info(info, options);\n}\n/**\n * Stream command for YouTube using info from video_info or decipher_info function.\n * @param info video_info data\n * @param options lets you add quality for stream\n * @returns Stream class with type and stream for playing.\n */\nexport async function stream_from_info(\n    info: InfoData | StreamInfoData,\n    options: StreamOptions = {}\n): Promise<YouTubeStream> {\n    if (info.format.length === 0)\n        throw new Error('Upcoming and premiere videos that are not currently live cannot be streamed.');\n    if (options.quality && !Number.isInteger(options.quality))\n        throw new Error(\"Quality must be set to an integer.\")\n\n    const final: any[] = [];\n    if (\n        info.LiveStreamData.isLive === true &&\n        info.LiveStreamData.dashManifestUrl !== null &&\n        info.video_details.durationInSec === 0\n    ) {\n        return new LiveStream(\n            info.LiveStreamData.dashManifestUrl,\n            info.format[info.format.length - 1].targetDurationSec as number,\n            info.video_details.url,\n            options.precache\n        );\n    }\n\n    const audioFormat = parseAudioFormats(info.format);\n    if (typeof options.quality !== 'number') options.quality = audioFormat.length - 1;\n    else if (options.quality <= 0) options.quality = 0;\n    else if (options.quality >= audioFormat.length) options.quality = audioFormat.length - 1;\n    if (audioFormat.length !== 0) final.push(audioFormat[options.quality]);\n    else final.push(info.format[info.format.length - 1]);\n    let type: StreamType =\n        final[0].codec === 'opus' && final[0].container === 'webm' ? StreamType.WebmOpus : StreamType.Arbitrary;\n    await request_stream(`https://${new URL(final[0].url).host}/generate_204`);\n    if (type === StreamType.WebmOpus) {\n        if (!options.discordPlayerCompatibility) {\n            options.seek ??= 0;\n            if (options.seek >= info.video_details.durationInSec || options.seek < 0)\n                throw new Error(`Seeking beyond limit. [ 0 - ${info.video_details.durationInSec - 1}]`);\n            return new SeekStream(\n                final[0].url,\n                info.video_details.durationInSec,\n                final[0].indexRange.end,\n                Number(final[0].contentLength),\n                Number(final[0].bitrate),\n                info.video_details.url,\n                options\n            );\n        } else if (options.seek) throw new Error('Can not seek with discordPlayerCompatibility set to true.');\n    }\n\n    let contentLength;\n    if (final[0].contentLength) {\n        contentLength = Number(final[0].contentLength);\n    } else {\n        contentLength = await request_content_length(final[0].url);\n    }\n\n    return new Stream(\n        final[0].url,\n        type,\n        info.video_details.durationInSec,\n        contentLength,\n        info.video_details.url,\n        options\n    );\n}\n","import { YouTubeVideo } from '../classes/Video';\nimport { YouTubePlayList } from '../classes/Playlist';\nimport { YouTubeChannel } from '../classes/Channel';\nimport { YouTube } from '..';\nimport { YouTubeThumbnail } from '../classes/Thumbnail';\n\nconst BLURRED_THUMBNAILS = [\n    '-oaymwEpCOADEI4CSFryq4qpAxsIARUAAAAAGAElAADIQj0AgKJDeAHtAZmZGUI=',\n    '-oaymwEiCOADEI4CSFXyq4qpAxQIARUAAIhCGAFwAcABBu0BmZkZQg==',\n    '-oaymwEiCOgCEMoBSFXyq4qpAxQIARUAAIhCGAFwAcABBu0BZmbmQQ==',\n    '-oaymwEiCNAFEJQDSFXyq4qpAxQIARUAAIhCGAFwAcABBu0BZmZmQg==',\n    '-oaymwEdCNAFEJQDSFryq4qpAw8IARUAAIhCGAHtAWZmZkI=',\n    '-oaymwEdCNACELwBSFryq4qpAw8IARUAAIhCGAHtAT0K10E='\n];\n\nexport interface ParseSearchInterface {\n    type?: 'video' | 'playlist' | 'channel';\n    limit?: number;\n    language?: string;\n    unblurNSFWThumbnails?: boolean;\n}\n\nexport interface thumbnail {\n    width: string;\n    height: string;\n    url: string;\n}\n/**\n * Main command which converts html body data and returns the type of data requested.\n * @param html body of that request\n * @param options limit & type of YouTube search you want.\n * @returns Array of one of YouTube type.\n */\nexport function ParseSearchResult(html: string, options?: ParseSearchInterface): YouTube[] {\n    if (!html) throw new Error(\"Can't parse Search result without data\");\n    if (!options) options = { type: 'video', limit: 0 };\n    else if (!options.type) options.type = 'video';\n    const hasLimit = typeof options.limit === 'number' && options.limit > 0;\n    options.unblurNSFWThumbnails ??= false;\n\n    const data = html\n        .split('var ytInitialData = ')?.[1]\n        ?.split(';</script>')[0]\n        .split(/;\\s*(var|const|let)\\s/)[0];\n    const json_data = JSON.parse(data);\n    const results = [];\n    const details =\n        json_data.contents.twoColumnSearchResultsRenderer.primaryContents.sectionListRenderer.contents.flatMap(\n            (s: any) => s.itemSectionRenderer?.contents\n        );\n    for (const detail of details) {\n        if (hasLimit && results.length === options.limit) break;\n        if (!detail || (!detail.videoRenderer && !detail.channelRenderer && !detail.playlistRenderer)) continue;\n        switch (options.type) {\n            case 'video': {\n                const parsed = parseVideo(detail);\n                if (parsed) {\n                    if (options.unblurNSFWThumbnails) parsed.thumbnails.forEach(unblurThumbnail);\n                    results.push(parsed);\n                }\n                break;\n            }\n            case 'channel': {\n                const parsed = parseChannel(detail);\n                if (parsed) results.push(parsed);\n                break;\n            }\n            case 'playlist': {\n                const parsed = parsePlaylist(detail);\n                if (parsed) {\n                    if (options.unblurNSFWThumbnails && parsed.thumbnail) unblurThumbnail(parsed.thumbnail);\n                    results.push(parsed);\n                }\n                break;\n            }\n            default:\n                throw new Error(`Unknown search type: ${options.type}`);\n        }\n    }\n    return results;\n}\n/**\n * Function to convert [hour : minutes : seconds] format to seconds\n * @param duration hour : minutes : seconds format\n * @returns seconds\n */\nfunction parseDuration(duration: string): number {\n    if (!duration) return 0;\n    const args = duration.split(':');\n    let dur = 0;\n\n    switch (args.length) {\n        case 3:\n            dur = parseInt(args[0]) * 60 * 60 + parseInt(args[1]) * 60 + parseInt(args[2]);\n            break;\n        case 2:\n            dur = parseInt(args[0]) * 60 + parseInt(args[1]);\n            break;\n        default:\n            dur = parseInt(args[0]);\n    }\n\n    return dur;\n}\n/**\n * Function to parse Channel searches\n * @param data body of that channel request.\n * @returns YouTubeChannel class\n */\nexport function parseChannel(data?: any): YouTubeChannel {\n    if (!data || !data.channelRenderer) throw new Error('Failed to Parse YouTube Channel');\n    const badge = data.channelRenderer.ownerBadges?.[0]?.metadataBadgeRenderer?.style?.toLowerCase();\n    const url = `https://www.youtube.com${\n        data.channelRenderer.navigationEndpoint.browseEndpoint.canonicalBaseUrl ||\n        data.channelRenderer.navigationEndpoint.commandMetadata.webCommandMetadata.url\n    }`;\n    const thumbnail = data.channelRenderer.thumbnail.thumbnails[data.channelRenderer.thumbnail.thumbnails.length - 1];\n    const res = new YouTubeChannel({\n        id: data.channelRenderer.channelId,\n        name: data.channelRenderer.title.simpleText,\n        icon: {\n            url: thumbnail.url.replace('//', 'https://'),\n            width: thumbnail.width,\n            height: thumbnail.height\n        },\n        url: url,\n        verified: Boolean(badge?.includes('verified')),\n        artist: Boolean(badge?.includes('artist')),\n        subscribers: data.channelRenderer.subscriberCountText?.simpleText ?? '0 subscribers'\n    });\n\n    return res;\n}\n/**\n * Function to parse Video searches\n * @param data body of that video request.\n * @returns YouTubeVideo class\n */\nexport function parseVideo(data?: any): YouTubeVideo {\n    if (!data || !data.videoRenderer) throw new Error('Failed to Parse YouTube Video');\n\n    const channel = data.videoRenderer.ownerText.runs[0];\n    const badge = data.videoRenderer.ownerBadges?.[0]?.metadataBadgeRenderer?.style?.toLowerCase();\n    const durationText = data.videoRenderer.lengthText;\n    const res = new YouTubeVideo({\n        id: data.videoRenderer.videoId,\n        url: `https://www.youtube.com/watch?v=${data.videoRenderer.videoId}`,\n        title: data.videoRenderer.title.runs[0].text,\n        description: data.videoRenderer.detailedMetadataSnippets?.[0].snippetText.runs?.length\n            ? data.videoRenderer.detailedMetadataSnippets[0].snippetText.runs.map((run: any) => run.text).join('')\n            : '',\n        duration: durationText ? parseDuration(durationText.simpleText) : 0,\n        duration_raw: durationText ? durationText.simpleText : null,\n        thumbnails: data.videoRenderer.thumbnail.thumbnails,\n        channel: {\n            id: channel.navigationEndpoint.browseEndpoint.browseId || null,\n            name: channel.text || null,\n            url: `https://www.youtube.com${\n                channel.navigationEndpoint.browseEndpoint.canonicalBaseUrl ||\n                channel.navigationEndpoint.commandMetadata.webCommandMetadata.url\n            }`,\n            icons: data.videoRenderer.channelThumbnailSupportedRenderers.channelThumbnailWithLinkRenderer.thumbnail\n                .thumbnails,\n            verified: Boolean(badge?.includes('verified')),\n            artist: Boolean(badge?.includes('artist'))\n        },\n        uploadedAt: data.videoRenderer.publishedTimeText?.simpleText ?? null,\n        upcoming: data.videoRenderer.upcomingEventData?.startTime\n            ? new Date(parseInt(data.videoRenderer.upcomingEventData.startTime) * 1000)\n            : undefined,\n        views: data.videoRenderer.viewCountText?.simpleText?.replace(/\\D/g, '') ?? 0,\n        live: durationText ? false : true\n    });\n\n    return res;\n}\n/**\n * Function to parse Playlist searches\n * @param data body of that playlist request.\n * @returns YouTubePlaylist class\n */\nexport function parsePlaylist(data?: any): YouTubePlayList {\n    if (!data || !data.playlistRenderer) throw new Error('Failed to Parse YouTube Playlist');\n\n    const thumbnail =\n        data.playlistRenderer.thumbnails[0].thumbnails[data.playlistRenderer.thumbnails[0].thumbnails.length - 1];\n    const channel = data.playlistRenderer.shortBylineText.runs?.[0];\n\n    const res = new YouTubePlayList(\n        {\n            id: data.playlistRenderer.playlistId,\n            title: data.playlistRenderer.title.simpleText,\n            thumbnail: {\n                id: data.playlistRenderer.playlistId,\n                url: thumbnail.url,\n                height: thumbnail.height,\n                width: thumbnail.width\n            },\n            channel: {\n                id: channel?.navigationEndpoint.browseEndpoint.browseId,\n                name: channel?.text,\n                url: `https://www.youtube.com${channel?.navigationEndpoint.commandMetadata.webCommandMetadata.url}`\n            },\n            videos: parseInt(data.playlistRenderer.videoCount.replace(/\\D/g, ''))\n        },\n        true\n    );\n\n    return res;\n}\n\nfunction unblurThumbnail(thumbnail: YouTubeThumbnail) {\n    if (BLURRED_THUMBNAILS.find((sqp) => thumbnail.url.includes(sqp))) {\n        thumbnail.url = thumbnail.url.split('?')[0];\n\n        // we need to update the size parameters as the sqp parameter also included a cropped size\n        switch (thumbnail.url.split('/').at(-1)!.split('.')[0]) {\n            case 'hq2':\n            case 'hqdefault':\n                thumbnail.width = 480;\n                thumbnail.height = 360;\n                break;\n            case 'hq720':\n                thumbnail.width = 1280;\n                thumbnail.height = 720;\n                break;\n            case 'sddefault':\n                thumbnail.width = 640;\n                thumbnail.height = 480;\n                break;\n            case 'mqdefault':\n                thumbnail.width = 320;\n                thumbnail.height = 180;\n                break;\n            case 'default':\n                thumbnail.width = 120;\n                thumbnail.height = 90;\n                break;\n            default:\n                thumbnail.width = thumbnail.height = NaN;\n        }\n    }\n}\n","import { request } from './../Request';\nimport { ParseSearchInterface, ParseSearchResult } from './utils/parser';\nimport { YouTubeVideo } from './classes/Video';\nimport { YouTubeChannel } from './classes/Channel';\nimport { YouTubePlayList } from './classes/Playlist';\n\nenum SearchType {\n    Video = 'EgIQAQ%253D%253D',\n    PlayList = 'EgIQAw%253D%253D',\n    Channel = 'EgIQAg%253D%253D'\n}\n\n/**\n * Type for YouTube returns\n */\nexport type YouTube = YouTubeVideo | YouTubeChannel | YouTubePlayList;\n/**\n * Command to search from YouTube\n * @param search The query to search\n * @param options limit & type of YouTube search you want.\n * @returns YouTube type.\n */\nexport async function yt_search(search: string, options: ParseSearchInterface = {}): Promise<YouTube[]> {\n    let url = 'https://www.youtube.com/results?search_query=' + search;\n    options.type ??= 'video';\n    if (url.indexOf('&sp=') === -1) {\n        url += '&sp=';\n        switch (options.type) {\n            case 'channel':\n                url += SearchType.Channel;\n                break;\n            case 'playlist':\n                url += SearchType.PlayList;\n                break;\n            case 'video':\n                url += SearchType.Video;\n                break;\n            default:\n                throw new Error(`Unknown search type: ${options.type}`);\n        }\n    }\n    const body = await request(url, {\n        headers: {\n            'accept-language': options.language || 'en-US;q=0.9'\n        }\n    });\n    if (body.indexOf('Our systems have detected unusual traffic from your computer network.') !== -1)\n        throw new Error('Captcha page: YouTube has detected that you are a bot!');\n    return ParseSearchResult(body, options);\n}\n","import { request } from '../Request';\nimport { SpotifyDataOptions } from '.';\nimport { AlbumJSON, PlaylistJSON, TrackJSON } from './constants';\n\nexport interface SpotifyTrackAlbum {\n    /**\n     * Spotify Track Album name\n     */\n    name: string;\n    /**\n     * Spotify Track Album url\n     */\n    url: string;\n    /**\n     * Spotify Track Album id\n     */\n    id: string;\n    /**\n     * Spotify Track Album release date\n     */\n    release_date: string;\n    /**\n     * Spotify Track Album release date **precise**\n     */\n    release_date_precision: string;\n    /**\n     * Spotify Track Album total tracks number\n     */\n    total_tracks: number;\n}\n\nexport interface SpotifyArtists {\n    /**\n     * Spotify Artist Name\n     */\n    name: string;\n    /**\n     * Spotify Artist Url\n     */\n    url: string;\n    /**\n     * Spotify Artist ID\n     */\n    id: string;\n}\n\nexport interface SpotifyThumbnail {\n    /**\n     * Spotify Thumbnail height\n     */\n    height: number;\n    /**\n     * Spotify Thumbnail width\n     */\n    width: number;\n    /**\n     * Spotify Thumbnail url\n     */\n    url: string;\n}\n\nexport interface SpotifyCopyright {\n    /**\n     * Spotify Copyright Text\n     */\n    text: string;\n    /**\n     * Spotify Copyright Type\n     */\n    type: string;\n}\n/**\n * Spotify Track Class\n */\nexport class SpotifyTrack {\n    /**\n     * Spotify Track Name\n     */\n    name: string;\n    /**\n     * Spotify Class type. == \"track\"\n     */\n    type: 'track' | 'playlist' | 'album';\n    /**\n     * Spotify Track ID\n     */\n    id: string;\n    /**\n     * Spotify Track url\n     */\n    url: string;\n    /**\n     * Spotify Track explicit info.\n     */\n    explicit: boolean;\n    /**\n     * Spotify Track playability info.\n     */\n    playable: boolean;\n    /**\n     * Spotify Track Duration in seconds\n     */\n    durationInSec: number;\n    /**\n     * Spotify Track Duration in milli seconds\n     */\n    durationInMs: number;\n    /**\n     * Spotify Track Artists data [ array ]\n     */\n    artists: SpotifyArtists[];\n    /**\n     * Spotify Track Album data\n     */\n    album: SpotifyTrackAlbum | undefined;\n    /**\n     * Spotify Track Thumbnail Data\n     */\n    thumbnail: SpotifyThumbnail | undefined;\n    /**\n     * Constructor for Spotify Track\n     * @param data\n     */\n    constructor(data: any) {\n        this.name = data.name;\n        this.id = data.id;\n        this.type = 'track';\n        this.url = data.external_urls.spotify;\n        this.explicit = data.explicit;\n        this.playable = data.is_playable;\n        this.durationInMs = data.duration_ms;\n        this.durationInSec = Math.round(this.durationInMs / 1000);\n        const artists: SpotifyArtists[] = [];\n        data.artists.forEach((v: any) => {\n            artists.push({\n                name: v.name,\n                id: v.id,\n                url: v.external_urls.spotify\n            });\n        });\n        this.artists = artists;\n        if (!data.album?.name) this.album = undefined;\n        else {\n            this.album = {\n                name: data.album.name,\n                url: data.external_urls.spotify,\n                id: data.album.id,\n                release_date: data.album.release_date,\n                release_date_precision: data.album.release_date_precision,\n                total_tracks: data.album.total_tracks\n            };\n        }\n        if (!data.album?.images?.[0]) this.thumbnail = undefined;\n        else this.thumbnail = data.album.images[0];\n    }\n\n    toJSON(): TrackJSON {\n        return {\n            name: this.name,\n            id: this.id,\n            url: this.url,\n            explicit: this.explicit,\n            durationInMs: this.durationInMs,\n            durationInSec: this.durationInSec,\n            artists: this.artists,\n            album: this.album,\n            thumbnail: this.thumbnail\n        };\n    }\n}\n/**\n * Spotify Playlist Class\n */\nexport class SpotifyPlaylist {\n    /**\n     * Spotify Playlist Name\n     */\n    name: string;\n    /**\n     * Spotify Class type. == \"playlist\"\n     */\n    type: 'track' | 'playlist' | 'album';\n    /**\n     * Spotify Playlist collaborative boolean.\n     */\n    collaborative: boolean;\n    /**\n     * Spotify Playlist Description\n     */\n    description: string;\n    /**\n     * Spotify Playlist URL\n     */\n    url: string;\n    /**\n     * Spotify Playlist ID\n     */\n    id: string;\n    /**\n     * Spotify Playlist Thumbnail Data\n     */\n    thumbnail: SpotifyThumbnail;\n    /**\n     * Spotify Playlist Owner Artist data\n     */\n    owner: SpotifyArtists;\n    /**\n     * Spotify Playlist total tracks Count\n     */\n    tracksCount: number;\n    /**\n     * Spotify Playlist Spotify data\n     *\n     * @private\n     */\n    private spotifyData: SpotifyDataOptions;\n    /**\n     * Spotify Playlist fetched tracks Map\n     *\n     * @private\n     */\n    private fetched_tracks: Map<string, SpotifyTrack[]>;\n    /**\n     * Boolean to tell whether it is a searched result or not.\n     */\n    private readonly search: boolean;\n    /**\n     * Constructor for Spotify Playlist Class\n     * @param data JSON parsed data of playlist\n     * @param spotifyData Data about sporify token for furhter fetching.\n     */\n    constructor(data: any, spotifyData: SpotifyDataOptions, search: boolean) {\n        this.name = data.name;\n        this.type = 'playlist';\n        this.search = search;\n        this.collaborative = data.collaborative;\n        this.description = data.description;\n        this.url = data.external_urls.spotify;\n        this.id = data.id;\n        this.thumbnail = data.images[0];\n        this.owner = {\n            name: data.owner.display_name,\n            url: data.owner.external_urls.spotify,\n            id: data.owner.id\n        };\n        this.tracksCount = Number(data.tracks.total);\n        const videos: SpotifyTrack[] = [];\n        if (!this.search)\n            data.tracks.items.forEach((v: any) => {\n                if (v.track) videos.push(new SpotifyTrack(v.track));\n            });\n        this.fetched_tracks = new Map();\n        this.fetched_tracks.set('1', videos);\n        this.spotifyData = spotifyData;\n    }\n    /**\n     * Fetches Spotify Playlist tracks more than 100 tracks.\n     *\n     * For getting all tracks in playlist, see `total_pages` property.\n     * @returns Playlist Class.\n     */\n    async fetch() {\n        if (this.search) return this;\n        let fetching: number;\n        if (this.tracksCount > 1000) fetching = 1000;\n        else fetching = this.tracksCount;\n        if (fetching <= 100) return this;\n        const work = [];\n        for (let i = 2; i <= Math.ceil(fetching / 100); i++) {\n            work.push(\n                new Promise(async (resolve, reject) => {\n                    const response = await request(\n                        `https://api.spotify.com/v1/playlists/${this.id}/tracks?offset=${\n                            (i - 1) * 100\n                        }&limit=100&market=${this.spotifyData.market}`,\n                        {\n                            headers: {\n                                Authorization: `${this.spotifyData.token_type} ${this.spotifyData.access_token}`\n                            }\n                        }\n                    ).catch((err) => reject(`Response Error : \\n${err}`));\n                    const videos: SpotifyTrack[] = [];\n                    if (typeof response !== 'string') return;\n                    const json_data = JSON.parse(response);\n                    json_data.items.forEach((v: any) => {\n                        if (v.track) videos.push(new SpotifyTrack(v.track));\n                    });\n                    this.fetched_tracks.set(`${i}`, videos);\n                    resolve('Success');\n                })\n            );\n        }\n        await Promise.allSettled(work);\n        return this;\n    }\n    /**\n     * Spotify Playlist tracks are divided in pages.\n     *\n     * For example getting data of 101 - 200 videos in a playlist,\n     *\n     * ```ts\n     * const playlist = await play.spotify('playlist url')\n     *\n     * await playlist.fetch()\n     *\n     * const result = playlist.page(2)\n     * ```\n     * @param num Page Number\n     * @returns\n     */\n    page(num: number) {\n        if (!num) throw new Error('Page number is not provided');\n        if (!this.fetched_tracks.has(`${num}`)) throw new Error('Given Page number is invalid');\n        return this.fetched_tracks.get(`${num}`) as SpotifyTrack[];\n    }\n    /**\n     * Gets total number of pages in that playlist class.\n     * @see {@link SpotifyPlaylist.all_tracks}\n     */\n    get total_pages() {\n        return this.fetched_tracks.size;\n    }\n    /**\n     * Spotify Playlist total no of tracks that have been fetched so far.\n     */\n    get total_tracks() {\n        if (this.search) return this.tracksCount;\n        const page_number: number = this.total_pages;\n        return (page_number - 1) * 100 + (this.fetched_tracks.get(`${page_number}`) as SpotifyTrack[]).length;\n    }\n    /**\n     * Fetches all the tracks in the playlist and returns them\n     *\n     * ```ts\n     * const playlist = await play.spotify('playlist url')\n     *\n     * const tracks = await playlist.all_tracks()\n     * ```\n     * @returns An array of {@link SpotifyTrack}\n     */\n    async all_tracks(): Promise<SpotifyTrack[]> {\n        await this.fetch();\n\n        const tracks: SpotifyTrack[] = [];\n\n        for (const page of this.fetched_tracks.values()) tracks.push(...page);\n\n        return tracks;\n    }\n    /**\n     * Converts Class to JSON\n     * @returns JSON data\n     */\n    toJSON(): PlaylistJSON {\n        return {\n            name: this.name,\n            collaborative: this.collaborative,\n            description: this.description,\n            url: this.url,\n            id: this.id,\n            thumbnail: this.thumbnail,\n            owner: this.owner,\n            tracksCount: this.tracksCount\n        };\n    }\n}\n/**\n * Spotify Album Class\n */\nexport class SpotifyAlbum {\n    /**\n     * Spotify Album Name\n     */\n    name: string;\n    /**\n     * Spotify Class type. == \"album\"\n     */\n    type: 'track' | 'playlist' | 'album';\n    /**\n     * Spotify Album url\n     */\n    url: string;\n    /**\n     * Spotify Album id\n     */\n    id: string;\n    /**\n     * Spotify Album Thumbnail data\n     */\n    thumbnail: SpotifyThumbnail;\n    /**\n     * Spotify Album artists [ array ]\n     */\n    artists: SpotifyArtists[];\n    /**\n     * Spotify Album copyright data [ array ]\n     */\n    copyrights: SpotifyCopyright[];\n    /**\n     * Spotify Album Release date\n     */\n    release_date: string;\n    /**\n     * Spotify Album Release Date **precise**\n     */\n    release_date_precision: string;\n    /**\n     * Spotify Album total no of tracks\n     */\n    tracksCount: number;\n    /**\n     * Spotify Album Spotify data\n     *\n     * @private\n     */\n    private spotifyData: SpotifyDataOptions;\n    /**\n     * Spotify Album fetched tracks Map\n     *\n     * @private\n     */\n    private fetched_tracks: Map<string, SpotifyTrack[]>;\n    /**\n     * Boolean to tell whether it is a searched result or not.\n     */\n    private readonly search: boolean;\n    /**\n     * Constructor for Spotify Album Class\n     * @param data Json parsed album data\n     * @param spotifyData Spotify credentials\n     */\n    constructor(data: any, spotifyData: SpotifyDataOptions, search: boolean) {\n        this.name = data.name;\n        this.type = 'album';\n        this.id = data.id;\n        this.search = search;\n        this.url = data.external_urls.spotify;\n        this.thumbnail = data.images[0];\n        const artists: SpotifyArtists[] = [];\n        data.artists.forEach((v: any) => {\n            artists.push({\n                name: v.name,\n                id: v.id,\n                url: v.external_urls.spotify\n            });\n        });\n        this.artists = artists;\n        this.copyrights = data.copyrights;\n        this.release_date = data.release_date;\n        this.release_date_precision = data.release_date_precision;\n        this.tracksCount = data.total_tracks;\n        const videos: SpotifyTrack[] = [];\n        if (!this.search)\n            data.tracks.items.forEach((v: any) => {\n                videos.push(new SpotifyTrack(v));\n            });\n        this.fetched_tracks = new Map();\n        this.fetched_tracks.set('1', videos);\n        this.spotifyData = spotifyData;\n    }\n    /**\n     * Fetches Spotify Album tracks more than 50 tracks.\n     *\n     * For getting all tracks in album, see `total_pages` property.\n     * @returns Album Class.\n     */\n    async fetch() {\n        if (this.search) return this;\n        let fetching: number;\n        if (this.tracksCount > 500) fetching = 500;\n        else fetching = this.tracksCount;\n        if (fetching <= 50) return this;\n        const work = [];\n        for (let i = 2; i <= Math.ceil(fetching / 50); i++) {\n            work.push(\n                new Promise(async (resolve, reject) => {\n                    const response = await request(\n                        `https://api.spotify.com/v1/albums/${this.id}/tracks?offset=${(i - 1) * 50}&limit=50&market=${\n                            this.spotifyData.market\n                        }`,\n                        {\n                            headers: {\n                                Authorization: `${this.spotifyData.token_type} ${this.spotifyData.access_token}`\n                            }\n                        }\n                    ).catch((err) => reject(`Response Error : \\n${err}`));\n                    const videos: SpotifyTrack[] = [];\n                    if (typeof response !== 'string') return;\n                    const json_data = JSON.parse(response);\n                    json_data.items.forEach((v: any) => {\n                        if (v) videos.push(new SpotifyTrack(v));\n                    });\n                    this.fetched_tracks.set(`${i}`, videos);\n                    resolve('Success');\n                })\n            );\n        }\n        await Promise.allSettled(work);\n        return this;\n    }\n    /**\n     * Spotify Album tracks are divided in pages.\n     *\n     * For example getting data of 51 - 100 videos in a album,\n     *\n     * ```ts\n     * const album = await play.spotify('album url')\n     *\n     * await album.fetch()\n     *\n     * const result = album.page(2)\n     * ```\n     * @param num Page Number\n     * @returns\n     */\n    page(num: number) {\n        if (!num) throw new Error('Page number is not provided');\n        if (!this.fetched_tracks.has(`${num}`)) throw new Error('Given Page number is invalid');\n        return this.fetched_tracks.get(`${num}`);\n    }\n    /**\n     * Gets total number of pages in that album class.\n     * @see {@link SpotifyAlbum.all_tracks}\n     */\n    get total_pages() {\n        return this.fetched_tracks.size;\n    }\n    /**\n     * Spotify Album total no of tracks that have been fetched so far.\n     */\n    get total_tracks() {\n        if (this.search) return this.tracksCount;\n        const page_number: number = this.total_pages;\n        return (page_number - 1) * 100 + (this.fetched_tracks.get(`${page_number}`) as SpotifyTrack[]).length;\n    }\n    /**\n     * Fetches all the tracks in the album and returns them\n     *\n     * ```ts\n     * const album = await play.spotify('album url')\n     *\n     * const tracks = await album.all_tracks()\n     * ```\n     * @returns An array of {@link SpotifyTrack}\n     */\n    async all_tracks(): Promise<SpotifyTrack[]> {\n        await this.fetch();\n\n        const tracks: SpotifyTrack[] = [];\n\n        for (const page of this.fetched_tracks.values()) tracks.push(...page);\n\n        return tracks;\n    }\n    /**\n     * Converts Class to JSON\n     * @returns JSON data\n     */\n    toJSON(): AlbumJSON {\n        return {\n            name: this.name,\n            id: this.id,\n            type: this.type,\n            url: this.url,\n            thumbnail: this.thumbnail,\n            artists: this.artists,\n            copyrights: this.copyrights,\n            release_date: this.release_date,\n            release_date_precision: this.release_date_precision,\n            tracksCount: this.tracksCount\n        };\n    }\n}\n","import { request } from '../Request';\nimport { SpotifyAlbum, SpotifyPlaylist, SpotifyTrack } from './classes';\nimport { existsSync, readFileSync, writeFileSync } from 'node:fs';\n\nlet spotifyData: SpotifyDataOptions;\nif (existsSync('.data/spotify.data')) {\n    spotifyData = JSON.parse(readFileSync('.data/spotify.data', 'utf-8'));\n    spotifyData.file = true;\n}\n/**\n * Spotify Data options that are stored in spotify.data file.\n */\nexport interface SpotifyDataOptions {\n    client_id: string;\n    client_secret: string;\n    redirect_url?: string;\n    authorization_code?: string;\n    access_token?: string;\n    refresh_token?: string;\n    token_type?: string;\n    expires_in?: number;\n    expiry?: number;\n    market?: string;\n    file?: boolean;\n}\n\nconst pattern = /^((https:)?\\/\\/)?open.spotify.com\\/(track|album|playlist)\\//;\n/**\n * Gets Spotify url details.\n *\n * ```ts\n * let spot = await play.spotify('spotify url')\n *\n * // spot.type === \"track\" | \"playlist\" | \"album\"\n *\n * if (spot.type === \"track\") {\n *      spot = spot as play.SpotifyTrack\n *      // Code with spotify track class.\n * }\n * ```\n * @param url Spotify Url\n * @returns A {@link SpotifyTrack} or {@link SpotifyPlaylist} or {@link SpotifyAlbum}\n */\nexport async function spotify(url: string): Promise<Spotify> {\n    if (!spotifyData) throw new Error('Spotify Data is missing\\nDid you forgot to do authorization ?');\n    const url_ = url.trim();\n    if (!url_.match(pattern)) throw new Error('This is not a Spotify URL');\n    if (url_.indexOf('track/') !== -1) {\n        const trackID = url_.split('track/')[1].split('&')[0].split('?')[0];\n        const response = await request(`https://api.spotify.com/v1/tracks/${trackID}?market=${spotifyData.market}`, {\n            headers: {\n                Authorization: `${spotifyData.token_type} ${spotifyData.access_token}`\n            }\n        }).catch((err: Error) => {\n            return err;\n        });\n        if (response instanceof Error) throw response;\n        return new SpotifyTrack(JSON.parse(response));\n    } else if (url_.indexOf('album/') !== -1) {\n        const albumID = url.split('album/')[1].split('&')[0].split('?')[0];\n        const response = await request(`https://api.spotify.com/v1/albums/${albumID}?market=${spotifyData.market}`, {\n            headers: {\n                Authorization: `${spotifyData.token_type} ${spotifyData.access_token}`\n            }\n        }).catch((err: Error) => {\n            return err;\n        });\n        if (response instanceof Error) throw response;\n        return new SpotifyAlbum(JSON.parse(response), spotifyData, false);\n    } else if (url_.indexOf('playlist/') !== -1) {\n        const playlistID = url.split('playlist/')[1].split('&')[0].split('?')[0];\n        const response = await request(\n            `https://api.spotify.com/v1/playlists/${playlistID}?market=${spotifyData.market}`,\n            {\n                headers: {\n                    Authorization: `${spotifyData.token_type} ${spotifyData.access_token}`\n                }\n            }\n        ).catch((err: Error) => {\n            return err;\n        });\n        if (response instanceof Error) throw response;\n        return new SpotifyPlaylist(JSON.parse(response), spotifyData, false);\n    } else throw new Error('URL is out of scope for play-dl.');\n}\n/**\n * Validate Spotify url\n * @param url Spotify URL\n * @returns\n * ```ts\n * 'track' | 'playlist' | 'album' | 'search' | false\n * ```\n */\nexport function sp_validate(url: string): 'track' | 'playlist' | 'album' | 'search' | false {\n    const url_ = url.trim();\n    if (!url_.startsWith('https')) return 'search';\n    if (!url_.match(pattern)) return false;\n    if (url_.indexOf('track/') !== -1) {\n        return 'track';\n    } else if (url_.indexOf('album/') !== -1) {\n        return 'album';\n    } else if (url_.indexOf('playlist/') !== -1) {\n        return 'playlist';\n    } else return false;\n}\n/**\n * Fuction for authorizing for spotify data.\n * @param data Sportify Data options to validate\n * @returns boolean.\n */\nexport async function SpotifyAuthorize(data: SpotifyDataOptions, file: boolean): Promise<boolean> {\n    const response = await request(`https://accounts.spotify.com/api/token`, {\n        headers: {\n            'Authorization': `Basic ${Buffer.from(`${data.client_id}:${data.client_secret}`).toString('base64')}`,\n            'Content-Type': 'application/x-www-form-urlencoded'\n        },\n        body: `grant_type=authorization_code&code=${data.authorization_code}&redirect_uri=${encodeURI(\n            data.redirect_url as string\n        )}`,\n        method: 'POST'\n    }).catch((err: Error) => {\n        return err;\n    });\n    if (response instanceof Error) throw response;\n    const resp_json = JSON.parse(response);\n    spotifyData = {\n        client_id: data.client_id,\n        client_secret: data.client_secret,\n        redirect_url: data.redirect_url,\n        access_token: resp_json.access_token,\n        refresh_token: resp_json.refresh_token,\n        expires_in: Number(resp_json.expires_in),\n        expiry: Date.now() + (resp_json.expires_in - 1) * 1000,\n        token_type: resp_json.token_type,\n        market: data.market\n    };\n    if (file) writeFileSync('.data/spotify.data', JSON.stringify(spotifyData, undefined, 4));\n    else {\n        console.log(`Client ID : ${spotifyData.client_id}`);\n        console.log(`Client Secret : ${spotifyData.client_secret}`);\n        console.log(`Refresh Token : ${spotifyData.refresh_token}`);\n        console.log(`Market : ${spotifyData.market}`);\n        console.log(`\\nPaste above info in setToken function.`);\n    }\n    return true;\n}\n/**\n * Checks if spotify token is expired or not.\n *\n * Update token if returned false.\n * ```ts\n * if (play.is_expired()) {\n *      await play.refreshToken()\n * }\n * ```\n * @returns boolean\n */\nexport function is_expired(): boolean {\n    if (Date.now() >= (spotifyData.expiry as number)) return true;\n    else return false;\n}\n/**\n * type for Spotify Classes\n */\nexport type Spotify = SpotifyAlbum | SpotifyPlaylist | SpotifyTrack;\n/**\n * Function for searching songs on Spotify\n * @param query searching query\n * @param type \"album\" | \"playlist\" | \"track\"\n * @param limit max no of results\n * @returns Spotify type.\n */\nexport async function sp_search(\n    query: string,\n    type: 'album' | 'playlist' | 'track',\n    limit: number = 10\n): Promise<Spotify[]> {\n    const results: Spotify[] = [];\n    if (!spotifyData) throw new Error('Spotify Data is missing\\nDid you forget to do authorization ?');\n    if (query.length === 0) throw new Error('Pass some query to search.');\n    if (limit > 50 || limit < 0) throw new Error(`You crossed limit range of Spotify [ 0 - 50 ]`);\n    const response = await request(\n        `https://api.spotify.com/v1/search?type=${type}&q=${query}&limit=${limit}&market=${spotifyData.market}`,\n        {\n            headers: {\n                Authorization: `${spotifyData.token_type} ${spotifyData.access_token}`\n            }\n        }\n    ).catch((err: Error) => {\n        return err;\n    });\n    if (response instanceof Error) throw response;\n    const json_data = JSON.parse(response);\n    if (type === 'track') {\n        json_data.tracks.items.forEach((track: any) => {\n            results.push(new SpotifyTrack(track));\n        });\n    } else if (type === 'album') {\n        json_data.albums.items.forEach((album: any) => {\n            results.push(new SpotifyAlbum(album, spotifyData, true));\n        });\n    } else if (type === 'playlist') {\n        json_data.playlists.items.forEach((playlist: any) => {\n            results.push(new SpotifyPlaylist(playlist, spotifyData, true));\n        });\n    }\n    return results;\n}\n/**\n * Refreshes Token\n *\n * ```ts\n * if (play.is_expired()) {\n *      await play.refreshToken()\n * }\n * ```\n * @returns boolean\n */\nexport async function refreshToken(): Promise<boolean> {\n    const response = await request(`https://accounts.spotify.com/api/token`, {\n        headers: {\n            'Authorization': `Basic ${Buffer.from(`${spotifyData.client_id}:${spotifyData.client_secret}`).toString(\n                'base64'\n            )}`,\n            'Content-Type': 'application/x-www-form-urlencoded'\n        },\n        body: `grant_type=refresh_token&refresh_token=${spotifyData.refresh_token}`,\n        method: 'POST'\n    }).catch((err: Error) => {\n        return err;\n    });\n    if (response instanceof Error) return false;\n    const resp_json = JSON.parse(response);\n    spotifyData.access_token = resp_json.access_token;\n    spotifyData.expires_in = Number(resp_json.expires_in);\n    spotifyData.expiry = Date.now() + (resp_json.expires_in - 1) * 1000;\n    spotifyData.token_type = resp_json.token_type;\n    if (spotifyData.file) writeFileSync('.data/spotify.data', JSON.stringify(spotifyData, undefined, 4));\n    return true;\n}\n\nexport async function setSpotifyToken(options: SpotifyDataOptions) {\n    spotifyData = options;\n    spotifyData.file = false;\n    await refreshToken();\n}\n\nexport { SpotifyTrack, SpotifyAlbum, SpotifyPlaylist };\n","import { existsSync, readFileSync } from 'node:fs';\nimport { StreamType } from '../YouTube/stream';\nimport { request } from '../Request';\nimport { SoundCloudPlaylist, SoundCloudTrack, SoundCloudTrackFormat, SoundCloudStream } from './classes';\nlet soundData: SoundDataOptions;\nif (existsSync('.data/soundcloud.data')) {\n    soundData = JSON.parse(readFileSync('.data/soundcloud.data', 'utf-8'));\n}\n\ninterface SoundDataOptions {\n    client_id: string;\n}\n\nconst pattern = /^(?:(https?):\\/\\/)?(?:(?:www|m)\\.)?(api\\.soundcloud\\.com|soundcloud\\.com|snd\\.sc)\\/(.*)$/;\n/**\n * Gets info from a soundcloud url.\n *\n * ```ts\n * let sound = await play.soundcloud('soundcloud url')\n *\n * // sound.type === \"track\" | \"playlist\" | \"user\"\n *\n * if (sound.type === \"track\") {\n *      spot = spot as play.SoundCloudTrack\n *      // Code with SoundCloud track class.\n * }\n * ```\n * @param url soundcloud url\n * @returns A {@link SoundCloudTrack} or {@link SoundCloudPlaylist}\n */\nexport async function soundcloud(url: string): Promise<SoundCloud> {\n    if (!soundData) throw new Error('SoundCloud Data is missing\\nDid you forget to do authorization ?');\n    const url_ = url.trim();\n    if (!url_.match(pattern)) throw new Error('This is not a SoundCloud URL');\n\n    const data = await request(\n        `https://api-v2.soundcloud.com/resolve?url=${url_}&client_id=${soundData.client_id}`\n    ).catch((err: Error) => err);\n\n    if (data instanceof Error) throw data;\n\n    const json_data = JSON.parse(data);\n\n    if (json_data.kind !== 'track' && json_data.kind !== 'playlist')\n        throw new Error('This url is out of scope for play-dl.');\n\n    if (json_data.kind === 'track') return new SoundCloudTrack(json_data);\n    else return new SoundCloudPlaylist(json_data, soundData.client_id);\n}\n/**\n * Type of SoundCloud\n */\nexport type SoundCloud = SoundCloudTrack | SoundCloudPlaylist;\n/**\n * Function for searching in SoundCloud\n * @param query query to search\n * @param type 'tracks' | 'playlists' | 'albums'\n * @param limit max no. of results\n * @returns Array of SoundCloud type.\n */\nexport async function so_search(\n    query: string,\n    type: 'tracks' | 'playlists' | 'albums',\n    limit: number = 10\n): Promise<SoundCloud[]> {\n    const response = await request(\n        `https://api-v2.soundcloud.com/search/${type}?q=${query}&client_id=${soundData.client_id}&limit=${limit}`\n    );\n    const results: (SoundCloudPlaylist | SoundCloudTrack)[] = [];\n    const json_data = JSON.parse(response);\n    json_data.collection.forEach((x: any) => {\n        if (type === 'tracks') results.push(new SoundCloudTrack(x));\n        else results.push(new SoundCloudPlaylist(x, soundData.client_id));\n    });\n    return results;\n}\n/**\n * Main Function for creating a Stream of soundcloud\n * @param url soundcloud url\n * @param quality Quality to select from\n * @returns SoundCloud Stream\n */\nexport async function stream(url: string, quality?: number): Promise<SoundCloudStream> {\n    const data = await soundcloud(url);\n\n    if (data instanceof SoundCloudPlaylist) throw new Error(\"Streams can't be created from playlist urls\");\n\n    const HLSformats = parseHlsFormats(data.formats);\n    if (typeof quality !== 'number') quality = HLSformats.length - 1;\n    else if (quality <= 0) quality = 0;\n    else if (quality >= HLSformats.length) quality = HLSformats.length - 1;\n    const req_url = HLSformats[quality].url + '?client_id=' + soundData.client_id;\n    const s_data = JSON.parse(await request(req_url));\n    const type = HLSformats[quality].format.mime_type.startsWith('audio/ogg')\n        ? StreamType.OggOpus\n        : StreamType.Arbitrary;\n    return new SoundCloudStream(s_data.url, type);\n}\n/**\n * Gets Free SoundCloud Client ID.\n *\n * Use this in beginning of your code to add SoundCloud support.\n *\n * ```ts\n * play.getFreeClientID().then((clientID) => play.setToken({\n *      soundcloud : {\n *          client_id : clientID\n *      }\n * }))\n * ```\n * @returns client ID\n */\nexport async function getFreeClientID(): Promise<string> {\n    const data = await request('https://soundcloud.com/');\n    const splitted = data.split('<script crossorigin src=\"');\n    const urls: string[] = [];\n    splitted.forEach((r) => {\n        if (r.startsWith('https')) {\n            urls.push(r.split('\"')[0]);\n        }\n    });\n    const data2 = await request(urls[urls.length - 1]);\n    return data2.split(',client_id:\"')[1].split('\"')[0];\n}\n/**\n * Function for creating a Stream of soundcloud using a SoundCloud Track Class\n * @param data SoundCloud Track Class\n * @param quality Quality to select from\n * @returns SoundCloud Stream\n */\nexport async function stream_from_info(data: SoundCloudTrack, quality?: number): Promise<SoundCloudStream> {\n    const HLSformats = parseHlsFormats(data.formats);\n    if (typeof quality !== 'number') quality = HLSformats.length - 1;\n    else if (quality <= 0) quality = 0;\n    else if (quality >= HLSformats.length) quality = HLSformats.length - 1;\n    const req_url = HLSformats[quality].url + '?client_id=' + soundData.client_id;\n    const s_data = JSON.parse(await request(req_url));\n    const type = HLSformats[quality].format.mime_type.startsWith('audio/ogg')\n        ? StreamType.OggOpus\n        : StreamType.Arbitrary;\n    return new SoundCloudStream(s_data.url, type);\n}\n/**\n * Function to check client ID\n * @param id Client ID\n * @returns boolean\n */\nexport async function check_id(id: string): Promise<boolean> {\n    const response = await request(`https://api-v2.soundcloud.com/search?client_id=${id}&q=Rick+Roll&limit=0`).catch(\n        (err: Error) => {\n            return err;\n        }\n    );\n    if (response instanceof Error) return false;\n    else return true;\n}\n/**\n * Validates a soundcloud url\n * @param url soundcloud url\n * @returns\n * ```ts\n * false | 'track' | 'playlist'\n * ```\n */\nexport async function so_validate(url: string): Promise<false | 'track' | 'playlist' | 'search'> {\n    const url_ = url.trim();\n    if (!url_.startsWith('https')) return 'search';\n    if (!url_.match(pattern)) return false;\n    const data = await request(\n        `https://api-v2.soundcloud.com/resolve?url=${url_}&client_id=${soundData.client_id}`\n    ).catch((err: Error) => err);\n\n    if (data instanceof Error) return false;\n\n    const json_data = JSON.parse(data);\n    if (json_data.kind === 'track') return 'track';\n    else if (json_data.kind === 'playlist') return 'playlist';\n    else return false;\n}\n/**\n * Function to select only hls streams from SoundCloud format array\n * @param data SoundCloud Track Format data\n * @returns HLS Formats Array\n */\nfunction parseHlsFormats(data: SoundCloudTrackFormat[]) {\n    const result: SoundCloudTrackFormat[] = [];\n    data.forEach((format) => {\n        if (format.format.protocol === 'hls') result.push(format);\n    });\n    return result;\n}\n\nexport function setSoundCloudToken(options: SoundDataOptions) {\n    soundData = options;\n}\n\nexport { SoundCloudTrack, SoundCloudPlaylist, SoundCloudStream };\n","import { request, request_stream } from '../Request';\nimport { Readable } from 'node:stream';\nimport { IncomingMessage } from 'node:http';\nimport { StreamType } from '../YouTube/stream';\nimport { Timer } from '../YouTube/classes/LiveStream';\nimport { PlaylistJSON, SoundTrackJSON } from './constants';\n\nexport interface SoundCloudUser {\n    /**\n     * SoundCloud User Name\n     */\n    name: string;\n    /**\n     * SoundCloud User ID\n     */\n    id: string;\n    /**\n     * SoundCloud User URL\n     */\n    url: string;\n    /**\n     * SoundCloud Class type. == \"user\"\n     */\n    type: 'track' | 'playlist' | 'user';\n    /**\n     * SoundCloud User Verified status\n     */\n    verified: boolean;\n    /**\n     * SoundCloud User Description\n     */\n    description: string;\n    /**\n     * SoundCloud User First Name\n     */\n    first_name: string;\n    /**\n     * SoundCloud User Full Name\n     */\n    full_name: string;\n    /**\n     * SoundCloud User Last Name\n     */\n    last_name: string;\n    /**\n     * SoundCloud User thumbnail URL\n     */\n    thumbnail: string;\n}\n\nexport interface SoundCloudTrackDeprecated {\n    /**\n     * SoundCloud Track fetched status\n     */\n    fetched: boolean;\n    /**\n     * SoundCloud Track ID\n     */\n    id: number;\n    /**\n     * SoundCloud Class type. == \"track\"\n     */\n    type: 'track';\n}\n\nexport interface SoundCloudTrackFormat {\n    /**\n     * SoundCloud Track Format Url\n     */\n    url: string;\n    /**\n     * SoundCloud Track Format preset\n     */\n    preset: string;\n    /**\n     * SoundCloud Track Format Duration\n     */\n    duration: number;\n    /**\n     * SoundCloud Track Format data containing protocol and mime_type\n     */\n    format: {\n        protocol: string;\n        mime_type: string;\n    };\n    /**\n     * SoundCloud Track Format quality\n     */\n    quality: string;\n}\n/**\n * SoundCloud Track Class\n */\nexport class SoundCloudTrack {\n    /**\n     * SoundCloud Track Name\n     */\n    name: string;\n    /**\n     * SoundCloud Track ID\n     */\n    id: number;\n    /**\n     * SoundCloud Track url\n     */\n    url: string;\n    /**\n     * User friendly SoundCloud track URL\n     */\n    permalink: string;\n    /**\n     * SoundCloud Track fetched status\n     */\n    fetched: boolean;\n    /**\n     * SoundCloud Class type. === \"track\"\n     */\n    type: 'track' | 'playlist' | 'user';\n    /**\n     * SoundCloud Track Duration in seconds\n     */\n    durationInSec: number;\n    /**\n     * SoundCloud Track Duration in miili seconds\n     */\n    durationInMs: number;\n    /**\n     * SoundCloud Track formats data\n     */\n    formats: SoundCloudTrackFormat[];\n    /**\n     * SoundCloud Track Publisher Data\n     */\n    publisher: {\n        name: string;\n        id: number;\n        artist: string;\n        contains_music: boolean;\n        writer_composer: string;\n    } | null;\n    /**\n     * SoundCloud Track thumbnail\n     */\n    thumbnail: string;\n    /**\n     * SoundCloud Track user data\n     */\n    user: SoundCloudUser;\n    /**\n     * Constructor for SoundCloud Track Class\n     * @param data JSON parsed track html data\n     */\n    constructor(data: any) {\n        this.name = data.title;\n        this.id = data.id;\n        this.url = data.uri;\n        this.permalink = data.permalink_url;\n        this.fetched = true;\n        this.type = 'track';\n        this.durationInSec = Math.round(Number(data.duration) / 1000);\n        this.durationInMs = Number(data.duration);\n        if (data.publisher_metadata)\n            this.publisher = {\n                name: data.publisher_metadata.publisher,\n                id: data.publisher_metadata.id,\n                artist: data.publisher_metadata.artist,\n                contains_music: Boolean(data.publisher_metadata.contains_music) || false,\n                writer_composer: data.publisher_metadata.writer_composer\n            };\n        else this.publisher = null;\n        this.formats = data.media.transcodings;\n        this.user = {\n            name: data.user.username,\n            id: data.user.id,\n            type: 'user',\n            url: data.user.permalink_url,\n            verified: Boolean(data.user.verified) || false,\n            description: data.user.description,\n            first_name: data.user.first_name,\n            full_name: data.user.full_name,\n            last_name: data.user.last_name,\n            thumbnail: data.user.avatar_url\n        };\n        this.thumbnail = data.artwork_url;\n    }\n    /**\n     * Converts class to JSON\n     * @returns JSON parsed Data\n     */\n    toJSON(): SoundTrackJSON {\n        return {\n            name: this.name,\n            id: this.id,\n            url: this.url,\n            permalink: this.permalink,\n            fetched: this.fetched,\n            durationInMs: this.durationInMs,\n            durationInSec: this.durationInSec,\n            publisher: this.publisher,\n            formats: this.formats,\n            thumbnail: this.thumbnail,\n            user: this.user\n        };\n    }\n}\n/**\n * SoundCloud Playlist Class\n */\nexport class SoundCloudPlaylist {\n    /**\n     * SoundCloud Playlist Name\n     */\n    name: string;\n    /**\n     * SoundCloud Playlist ID\n     */\n    id: number;\n    /**\n     * SoundCloud Playlist URL\n     */\n    url: string;\n    /**\n     * SoundCloud Class type. == \"playlist\"\n     */\n    type: 'track' | 'playlist' | 'user';\n    /**\n     * SoundCloud Playlist Sub type. == \"album\" for soundcloud albums\n     */\n    sub_type: string;\n    /**\n     * SoundCloud Playlist Total Duration in seconds\n     */\n    durationInSec: number;\n    /**\n     * SoundCloud Playlist Total Duration in milli seconds\n     */\n    durationInMs: number;\n    /**\n     * SoundCloud Playlist user data\n     */\n    user: SoundCloudUser;\n    /**\n     * SoundCloud Playlist tracks [ It can be fetched or not fetched ]\n     */\n    tracks: SoundCloudTrack[] | SoundCloudTrackDeprecated[];\n    /**\n     * SoundCloud Playlist tracks number\n     */\n    tracksCount: number;\n    /**\n     * SoundCloud Client ID provided by user\n     * @private\n     */\n    private client_id: string;\n    /**\n     * Constructor for SoundCloud Playlist\n     * @param data JSON parsed SoundCloud playlist data\n     * @param client_id Provided SoundCloud Client ID\n     */\n    constructor(data: any, client_id: string) {\n        this.name = data.title;\n        this.id = data.id;\n        this.url = data.uri;\n        this.client_id = client_id;\n        this.type = 'playlist';\n        this.sub_type = data.set_type;\n        this.durationInSec = Math.round(Number(data.duration) / 1000);\n        this.durationInMs = Number(data.duration);\n        this.user = {\n            name: data.user.username,\n            id: data.user.id,\n            type: 'user',\n            url: data.user.permalink_url,\n            verified: Boolean(data.user.verified) || false,\n            description: data.user.description,\n            first_name: data.user.first_name,\n            full_name: data.user.full_name,\n            last_name: data.user.last_name,\n            thumbnail: data.user.avatar_url\n        };\n        this.tracksCount = data.track_count;\n        const tracks: any[] = [];\n        data.tracks.forEach((track: any) => {\n            if (track.title) {\n                tracks.push(new SoundCloudTrack(track));\n            } else\n                tracks.push({\n                    id: track.id,\n                    fetched: false,\n                    type: 'track'\n                });\n        });\n        this.tracks = tracks;\n    }\n    /**\n     * Fetches all unfetched songs in a playlist.\n     *\n     * For fetching songs and getting all songs, see `fetched_tracks` property.\n     * @returns playlist class\n     */\n    async fetch(): Promise<SoundCloudPlaylist> {\n        const work: any[] = [];\n        for (let i = 0; i < this.tracks.length; i++) {\n            if (!this.tracks[i].fetched) {\n                work.push(\n                    new Promise(async (resolve) => {\n                        const num = i;\n                        const data = await request(\n                            `https://api-v2.soundcloud.com/tracks/${this.tracks[i].id}?client_id=${this.client_id}`\n                        );\n\n                        this.tracks[num] = new SoundCloudTrack(JSON.parse(data));\n                        resolve('');\n                    })\n                );\n            }\n        }\n        await Promise.allSettled(work);\n        return this;\n    }\n    /**\n     * Get total no. of fetched tracks\n     * @see {@link SoundCloudPlaylist.all_tracks}\n     */\n    get total_tracks(): number {\n        let count = 0;\n        this.tracks.forEach((track) => {\n            if (track instanceof SoundCloudTrack) count++;\n            else return;\n        });\n        return count;\n    }\n    /**\n     * Fetches all the tracks in the playlist and returns them\n     *\n     * ```ts\n     * const playlist = await play.soundcloud('playlist url')\n     *\n     * const tracks = await playlist.all_tracks()\n     * ```\n     * @returns An array of {@link SoundCloudTrack}\n     */\n    async all_tracks(): Promise<SoundCloudTrack[]> {\n        await this.fetch();\n\n        return this.tracks as SoundCloudTrack[];\n    }\n    /**\n     * Converts Class to JSON data\n     * @returns JSON parsed data\n     */\n    toJSON(): PlaylistJSON {\n        return {\n            name: this.name,\n            id: this.id,\n            sub_type: this.sub_type,\n            url: this.url,\n            durationInMs: this.durationInMs,\n            durationInSec: this.durationInSec,\n            tracksCount: this.tracksCount,\n            user: this.user,\n            tracks: this.tracks\n        };\n    }\n}\n/**\n * SoundCloud Stream class\n */\nexport class SoundCloudStream {\n    /**\n     * Readable Stream through which data passes\n     */\n    stream: Readable;\n    /**\n     * Type of audio data that we recieved from normal youtube url.\n     */\n    type: StreamType;\n    /**\n     * Dash Url containing segment urls.\n     * @private\n     */\n    private url: string;\n    /**\n     * Total time of downloaded segments data.\n     * @private\n     */\n    private downloaded_time: number;\n    /**\n     * Timer for looping code every 5 minutes\n     * @private\n     */\n    private timer: Timer;\n    /**\n     * Total segments Downloaded so far\n     * @private\n     */\n    private downloaded_segments: number;\n    /**\n     * Incoming message that we recieve.\n     *\n     * Storing this is essential.\n     * This helps to destroy the TCP connection completely if you stopped player in between the stream\n     * @private\n     */\n    private request: IncomingMessage | null;\n    /**\n     * Array of segment time. Useful for calculating downloaded_time.\n     */\n    private time: number[];\n    /**\n     * Array of segment_urls in dash file.\n     */\n    private segment_urls: string[];\n    /**\n     * Constructor for SoundCloud Stream\n     * @param url Dash url containing dash file.\n     * @param type Stream Type\n     */\n    constructor(url: string, type: StreamType = StreamType.Arbitrary) {\n        this.stream = new Readable({ highWaterMark: 5 * 1000 * 1000, read() {} });\n        this.type = type;\n        this.url = url;\n        this.downloaded_time = 0;\n        this.request = null;\n        this.downloaded_segments = 0;\n        this.time = [];\n        this.timer = new Timer(() => {\n            this.timer.reuse();\n            this.start();\n        }, 280);\n        this.segment_urls = [];\n        this.stream.on('close', () => {\n            this.cleanup();\n        });\n        this.start();\n    }\n    /**\n     * Parses SoundCloud dash file.\n     * @private\n     */\n    private async parser() {\n        const response = await request(this.url).catch((err: Error) => {\n            return err;\n        });\n        if (response instanceof Error) throw response;\n        const array = response.split('\\n');\n        array.forEach((val) => {\n            if (val.startsWith('#EXTINF:')) {\n                this.time.push(parseFloat(val.replace('#EXTINF:', '')));\n            } else if (val.startsWith('https')) {\n                this.segment_urls.push(val);\n            }\n        });\n        return;\n    }\n    /**\n     * Starts looping of code for getting all segments urls data\n     */\n    private async start() {\n        if (this.stream.destroyed) {\n            this.cleanup();\n            return;\n        }\n        this.time = [];\n        this.segment_urls = [];\n        this.downloaded_time = 0;\n        await this.parser();\n        this.segment_urls.splice(0, this.downloaded_segments);\n        this.loop();\n    }\n    /**\n     * Main Loop function for getting all segments urls data\n     */\n    private async loop() {\n        if (this.stream.destroyed) {\n            this.cleanup();\n            return;\n        }\n        if (this.time.length === 0 || this.segment_urls.length === 0) {\n            this.cleanup();\n            this.stream.push(null);\n            return;\n        }\n        this.downloaded_time += this.time.shift() as number;\n        this.downloaded_segments++;\n        const stream = await request_stream(this.segment_urls.shift() as string).catch((err: Error) => err);\n        if (stream instanceof Error) {\n            this.stream.emit('error', stream);\n            this.cleanup();\n            return;\n        }\n\n        this.request = stream;\n        stream.on('data', (c) => {\n            this.stream.push(c);\n        });\n        stream.on('end', () => {\n            if (this.downloaded_time >= 300) return;\n            else this.loop();\n        });\n        stream.once('error', (err) => {\n            this.stream.emit('error', err);\n        });\n    }\n    /**\n     * This cleans every used variable in class.\n     *\n     * This is used to prevent re-use of this class and helping garbage collector to collect it.\n     */\n    private cleanup() {\n        this.timer.destroy();\n        this.request?.destroy();\n        this.url = '';\n        this.downloaded_time = 0;\n        this.downloaded_segments = 0;\n        this.request = null;\n        this.time = [];\n        this.segment_urls = [];\n    }\n    /**\n     * Pauses timer.\n     * Stops running of loop.\n     *\n     * Useful if you don't want to get excess data to be stored in stream.\n     */\n    pause() {\n        this.timer.pause();\n    }\n    /**\n     * Resumes timer.\n     * Starts running of loop.\n     */\n    resume() {\n        this.timer.resume();\n    }\n}\n","import { URL } from 'node:url';\nimport { request, request_resolve_redirect } from '../Request';\nimport { DeezerAlbum, DeezerPlaylist, DeezerTrack } from './classes';\n\ninterface TypeData {\n    type: 'track' | 'playlist' | 'album' | 'search' | false;\n    id?: string;\n    error?: string;\n}\n\ninterface DeezerSearchOptions {\n    /**\n     * The type to search for `'track'`, `'playlist'` or `'album'`. Defaults to `'track'`.\n     */\n    type?: 'track' | 'playlist' | 'album';\n    /**\n     * The maximum number of results to return, maximum `100`, defaults to `10`.\n     */\n    limit?: number;\n    /**\n     * Whether the search should be fuzzy or only return exact matches. Defaults to `true`.\n     */\n    fuzzy?: boolean;\n}\n\ninterface DeezerAdvancedSearchOptions {\n    /**\n     * The maximum number of results to return, maximum `100`, defaults to `10`.\n     */\n    limit?: number;\n    /**\n     * The name of the artist.\n     */\n    artist?: string;\n    /**\n     * The title of the album.\n     */\n    album?: string;\n    /**\n     * The title of the track.\n     */\n    title?: string;\n    /**\n     * The label that released the track.\n     */\n    label?: string;\n    /**\n     * The minimum duration in seconds.\n     */\n    minDurationInSec?: number;\n    /**\n     * The maximum duration in seconds.\n     */\n    maxDurationInSec?: number;\n    /**\n     * The minimum BPM.\n     */\n    minBPM?: number;\n    /**\n     * The minimum BPM.\n     */\n    maxBPM?: number;\n}\n\nasync function internalValidate(url: string): Promise<TypeData> {\n    let urlObj;\n    try {\n        // will throw a TypeError if the input is not a valid URL so we need to catch it\n        urlObj = new URL(url);\n    } catch {\n        return { type: 'search' };\n    }\n\n    if (urlObj.protocol !== 'https:' && urlObj.protocol !== 'http:') {\n        return { type: 'search' };\n    }\n\n    let pathname = urlObj.pathname;\n    if (pathname.endsWith('/')) {\n        pathname = pathname.slice(0, -1);\n    }\n    const path = pathname.split('/');\n    switch (urlObj.hostname) {\n        case 'deezer.com':\n        case 'www.deezer.com': {\n            if (path.length === 4) {\n                const lang = path.splice(1, 1)[0];\n                if (!lang.match(/^[a-z]{2}$/)) {\n                    return { type: false };\n                }\n            } else if (path.length !== 3) {\n                return { type: false };\n            }\n\n            if ((path[1] === 'track' || path[1] === 'album' || path[1] === 'playlist') && path[2].match(/^\\d+$/)) {\n                return {\n                    type: path[1],\n                    id: path[2]\n                };\n            } else {\n                return { type: false };\n            }\n        }\n        case 'api.deezer.com': {\n            if (\n                path.length === 3 &&\n                (path[1] === 'track' || path[1] === 'album' || path[1] === 'playlist') &&\n                path[2].match(/^\\d+$/)\n            ) {\n                return {\n                    type: path[1],\n                    id: path[2]\n                };\n            } else {\n                return { type: false };\n            }\n        }\n        case 'deezer.page.link': {\n            if (path.length === 2 && path[1].match(/^[A-Za-z0-9]+$/)) {\n                const resolved = await request_resolve_redirect(url).catch((err) => err);\n\n                if (resolved instanceof Error) {\n                    return { type: false, error: resolved.message };\n                }\n\n                return await internalValidate(resolved);\n            } else {\n                return { type: false };\n            }\n        }\n        default:\n            return { type: 'search' };\n    }\n}\n\n/**\n * Shared type for Deezer tracks, playlists and albums\n */\nexport type Deezer = DeezerTrack | DeezerPlaylist | DeezerAlbum;\n\n/**\n * Fetches the information for a track, playlist or album on Deezer\n * @param url The track, playlist or album URL\n * @returns A {@link DeezerTrack}, {@link DeezerPlaylist} or {@link DeezerAlbum}\n * object depending on the provided URL.\n */\nexport async function deezer(url: string): Promise<Deezer> {\n    const typeData = await internalValidate(url.trim());\n\n    if (typeData.error) {\n        throw new Error(`This is not a Deezer track, playlist or album URL:\\n${typeData.error}`);\n    } else if (!typeData.type || typeData.type === 'search')\n        throw new Error('This is not a Deezer track, playlist or album URL');\n\n    const response = await request(`https://api.deezer.com/${typeData.type}/${typeData.id}`).catch((err: Error) => err);\n\n    if (response instanceof Error) throw response;\n\n    const jsonData = JSON.parse(response);\n\n    if (jsonData.error) {\n        throw new Error(`Deezer API Error: ${jsonData.error.type}: ${jsonData.error.message}`);\n    }\n\n    switch (typeData.type) {\n        case 'track':\n            return new DeezerTrack(jsonData, false);\n        case 'playlist':\n            return new DeezerPlaylist(jsonData, false);\n        case 'album':\n            return new DeezerAlbum(jsonData, false);\n    }\n}\n\n/**\n * Validates a Deezer URL\n * @param url The URL to validate\n * @returns The type of the URL either `'track'`, `'playlist'`, `'album'`, `'search'` or `false`.\n * `false` means that the provided URL was a wrongly formatted or an unsupported Deezer URL.\n */\nexport async function dz_validate(url: string): Promise<'track' | 'playlist' | 'album' | 'search' | false> {\n    const typeData = await internalValidate(url.trim());\n    return typeData.type;\n}\n\n/**\n * Searches Deezer for tracks, playlists or albums\n * @param query The search query\n * @param options Extra options to configure the search:\n *\n * * type?: The type to search for `'track'`, `'playlist'` or `'album'`. Defaults to `'track'`.\n * * limit?: The maximum number of results to return, maximum `100`, defaults to `10`.\n * * fuzzy?: Whether the search should be fuzzy or only return exact matches. Defaults to `true`.\n * @returns An array of tracks, playlists or albums\n */\nexport async function dz_search(query: string, options: DeezerSearchOptions): Promise<Deezer[]> {\n    let query_ = query.trim();\n\n    const type = options.type ?? 'track';\n    const limit = options.limit ?? 10;\n    const fuzzy = options.fuzzy ?? true;\n\n    if (query_.length === 0) throw new Error('A query is required to search.');\n    if (limit > 100) throw new Error('The maximum search limit for Deezer is 100');\n    if (limit < 1) throw new Error('The minimum search limit for Deezer is 1');\n    if (type !== 'track' && type !== 'album' && type != 'playlist')\n        throw new Error(`\"${type}\" is not a valid Deezer search type`);\n\n    query_ = encodeURIComponent(query_);\n    const response = await request(\n        `https://api.deezer.com/search/${type}/?q=${query_}&limit=${limit}${fuzzy ? '' : 'strict=on'}`\n    ).catch((err: Error) => err);\n\n    if (response instanceof Error) throw response;\n\n    const jsonData = JSON.parse(response);\n\n    if (jsonData.error) {\n        throw new Error(`Deezer API Error: ${jsonData.error.type}: ${jsonData.error.message}`);\n    }\n\n    let results: Deezer[] = [];\n    switch (type) {\n        case 'track':\n            results = jsonData.data.map((track: any) => new DeezerTrack(track, true));\n            break;\n        case 'playlist':\n            results = jsonData.data.map((playlist: any) => new DeezerPlaylist(playlist, true));\n            break;\n        case 'album':\n            results = jsonData.data.map((album: any) => new DeezerAlbum(album, true));\n            break;\n    }\n\n    return results;\n}\n\n/**\n * Searches Deezer for tracks using the specified metadata.\n * @param options The metadata and limit for the search\n *\n * * limit?: The maximum number of results to return, maximum `100`, defaults to `10`.\n * * artist?: The name of the artist\n * * album?: The title of the album\n * * title?: The title of the track\n * * label?: The label that released the track\n * * minDurationInSec?: The minimum duration in seconds\n * * maxDurationInSec?: The maximum duration in seconds\n * * minBpm?: The minimum BPM\n * * maxBpm?: The minimum BPM\n * @returns An array of tracks matching the metadata\n */\nexport async function dz_advanced_track_search(options: DeezerAdvancedSearchOptions): Promise<DeezerTrack[]> {\n    const limit = options.limit ?? 10;\n\n    if (limit > 100) throw new Error('The maximum search limit for Deezer is 100');\n    if (limit < 1) throw new Error('The minimum search limit for Deezer is 1');\n\n    const metadata: string[] = [];\n    if (options.artist) metadata.push(`artist:\"${encodeURIComponent(options.artist.trim())}\"`);\n\n    if (options.album) metadata.push(`album:\"${encodeURIComponent(options.album.trim())}\"`);\n\n    if (options.title) metadata.push(`track:\"${encodeURIComponent(options.title.trim())}\"`);\n\n    if (options.label) metadata.push(`label:\"${encodeURIComponent(options.label.trim())}\"`);\n\n    if (!isNaN(Number(options.minDurationInSec))) metadata.push(`dur_min:${options.minDurationInSec}`);\n\n    if (!isNaN(Number(options.maxDurationInSec))) metadata.push(`dur_max:${options.maxDurationInSec}`);\n\n    if (!isNaN(Number(options.minBPM))) metadata.push(`bpm_min:${options.minBPM}`);\n\n    if (!isNaN(Number(options.maxBPM))) metadata.push(`bpm_max:${options.maxBPM}`);\n\n    if (metadata.length === 0) throw new Error('At least one type of metadata is required.');\n\n    const response = await request(`https://api.deezer.com/search/track/?q=${metadata.join(' ')}&limit=${limit}`).catch(\n        (err: Error) => err\n    );\n\n    if (response instanceof Error) throw response;\n\n    const jsonData = JSON.parse(response);\n\n    if (jsonData.error) {\n        throw new Error(`Deezer API Error: ${jsonData.error.type}: ${jsonData.error.message}`);\n    }\n\n    const results = jsonData.data.map((track: any) => new DeezerTrack(track, true));\n\n    return results;\n}\n\nexport { DeezerTrack, DeezerAlbum, DeezerPlaylist };\n","import { request } from '../Request';\n\n/**\n * Interface representing an image on Deezer\n * available in four sizes\n */\ninterface DeezerImage {\n    /**\n     * The largest version of the image\n     */\n    xl: string;\n    /**\n     * The second largest version of the image\n     */\n    big: string;\n    /**\n     * The second smallest version of the image\n     */\n    medium: string;\n    /**\n     * The smallest version of the image\n     */\n    small: string;\n}\n\n/**\n * Interface representing a Deezer genre\n */\ninterface DeezerGenre {\n    /**\n     * The name of the genre\n     */\n    name: string;\n    /**\n     * The thumbnail of the genre available in four sizes\n     */\n    picture: DeezerImage;\n}\n\n/**\n * Interface representing a Deezer user account\n */\ninterface DeezerUser {\n    /**\n     * The id of the user\n     */\n    id: number;\n    /**\n     * The name of the user\n     */\n    name: string;\n}\n\n/**\n * Class representing a Deezer track\n */\nexport class DeezerTrack {\n    /**\n     * The id of the track\n     */\n    id: number;\n    /**\n     * The title of the track\n     */\n    title: string;\n    /**\n     * A shorter version of the title\n     */\n    shortTitle: string;\n    /**\n     * The URL of the track on Deezer\n     */\n    url: string;\n    /**\n     * The duration of the track in seconds\n     */\n    durationInSec: number;\n    /**\n     * The rank of the track\n     */\n    rank: number;\n    /**\n     * `true` if the track contains any explicit lyrics\n     */\n    explicit: boolean;\n    /**\n     * URL to a file containing the first 30 seconds of the track\n     */\n    previewURL: string;\n    /**\n     * The artist of the track\n     */\n    artist: DeezerArtist;\n    /**\n     * The album that this track is in\n     */\n    album: DeezerTrackAlbum;\n    /**\n     * The type, always `'track'`, useful to determine what the deezer function returned\n     */\n    type: 'track' | 'playlist' | 'album';\n\n    /**\n     * Signifies that some properties are not populated\n     *\n     * Partial tracks can be populated by calling {@link DeezerTrack.fetch}.\n     *\n     * `true` for tracks in search results and `false` if the track was fetched directly or expanded.\n     */\n    partial: boolean;\n\n    /**\n     * The position of the track in the album\n     *\n     * `undefined` for partial tracks\n     *\n     * @see {@link DeezerTrack.partial}\n     */\n    trackPosition?: number;\n    /**\n     * The number of the disk the track is on\n     *\n     * `undefined` for partial tracks\n     *\n     * @see {@link DeezerTrack.partial}\n     */\n    diskNumber?: number;\n    /**\n     * The release date\n     *\n     * `undefined` for partial tracks\n     *\n     * @see {@link DeezerTrack.partial}\n     */\n    releaseDate?: Date;\n    /**\n     * The number of beats per minute\n     *\n     * `undefined` for partial tracks\n     *\n     * @see {@link DeezerTrack.partial}\n     */\n    bpm?: number;\n    /**\n     * The gain of the track\n     *\n     * `undefined` for partial tracks\n     *\n     * @see {@link DeezerTrack.partial}\n     */\n    gain?: number;\n    /**\n     * The artists that have contributed to the track\n     *\n     * `undefined` for partial tracks\n     *\n     * @see {@link DeezerTrack.partial}\n     */\n    contributors?: DeezerArtist[];\n\n    /**\n     * Creates a Deezer track from the data in an API response\n     * @param data the data to use to create the track\n     * @param partial Whether the track should be partial\n     * @see {@link DeezerTrack.partial}\n     */\n    constructor(data: any, partial: boolean) {\n        this.id = data.id;\n        this.title = data.title;\n        this.shortTitle = data.title_short;\n        this.url = data.link;\n        this.durationInSec = data.duration;\n        this.rank = data.rank;\n        this.explicit = data.explicit_lyrics;\n        this.previewURL = data.preview;\n        this.artist = new DeezerArtist(data.artist);\n        this.album = new DeezerTrackAlbum(data.album);\n        this.type = 'track';\n\n        this.partial = partial;\n\n        if (!partial) {\n            this.trackPosition = data.track_position;\n            this.diskNumber = data.disk_number;\n            this.releaseDate = new Date(data.release_date);\n            this.bpm = data.bpm;\n            this.gain = data.gain;\n            this.contributors = [];\n\n            data.contributors.forEach((contributor: any) => {\n                this.contributors?.push(new DeezerArtist(contributor));\n            });\n        }\n    }\n\n    /**\n     * Fetches and populates the missing fields\n     *\n     * The property {@link partial} will be `false` if this method finishes successfully.\n     *\n     * @returns A promise with the same track this method was called on.\n     */\n    async fetch(): Promise<DeezerTrack> {\n        if (!this.partial) return this;\n\n        const response = await request(`https://api.deezer.com/track/${this.id}/`).catch((err: Error) => err);\n\n        if (response instanceof Error) throw response;\n        const jsonData = JSON.parse(response);\n\n        this.partial = false;\n\n        this.trackPosition = jsonData.track_position;\n        this.diskNumber = jsonData.disk_number;\n        this.releaseDate = new Date(jsonData.release_date);\n        this.bpm = jsonData.bpm;\n        this.gain = jsonData.gain;\n        this.contributors = [];\n\n        jsonData.contributors.forEach((contributor: any) => {\n            this.contributors?.push(new DeezerArtist(contributor));\n        });\n\n        return this;\n    }\n    /**\n     * Converts instances of this class to JSON data\n     * @returns JSON data.\n     */\n    toJSON() {\n        return {\n            id: this.id,\n            title: this.title,\n            shortTitle: this.shortTitle,\n            url: this.url,\n            durationInSec: this.durationInSec,\n            rank: this.rank,\n            explicit: this.explicit,\n            previewURL: this.previewURL,\n            artist: this.artist,\n            album: this.album,\n            type: this.type,\n            trackPosition: this.trackPosition,\n            diskNumber: this.diskNumber,\n            releaseDate: this.releaseDate,\n            bpm: this.bpm,\n            gain: this.gain,\n            contributors: this.contributors\n        };\n    }\n}\n/**\n * Class for Deezer Albums\n */\nexport class DeezerAlbum {\n    /**\n     * The id of the album\n     */\n    id: number;\n    /**\n     * The title of the album\n     */\n    title: string;\n    /**\n     * The URL to the album on Deezer\n     */\n    url: string;\n    /**\n     * The record type of the album (e.g. EP, ALBUM, etc ...)\n     */\n    recordType: string;\n    /**\n     * `true` if the album contains any explicit lyrics\n     */\n    explicit: boolean;\n    /**\n     * The artist of the album\n     */\n    artist: DeezerArtist;\n    /**\n     * The album cover available in four sizes\n     */\n    cover: DeezerImage;\n    /**\n     * The type, always `'album'`, useful to determine what the deezer function returned\n     */\n    type: 'track' | 'playlist' | 'album';\n    /**\n     * The number of tracks in the album\n     */\n    tracksCount: number;\n\n    /**\n     * Signifies that some properties are not populated\n     *\n     * Partial albums can be populated by calling {@link DeezerAlbum.fetch}.\n     *\n     * `true` for albums in search results and `false` if the album was fetched directly or expanded.\n     */\n    partial: boolean;\n\n    /**\n     * The **u**niversal **p**roduct **c**ode of the album\n     *\n     * `undefined` for partial albums\n     *\n     * @see {@link DeezerAlbum.partial}\n     */\n    upc?: string;\n    /**\n     * The duration of the album in seconds\n     *\n     * `undefined` for partial albums\n     *\n     * @see {@link DeezerAlbum.partial}\n     */\n    durationInSec?: number;\n    /**\n     * The number of fans the album has\n     *\n     * `undefined` for partial albums\n     *\n     * @see {@link DeezerAlbum.partial}\n     */\n    numberOfFans?: number;\n    /**\n     * The release date of the album\n     *\n     * `undefined` for partial albums\n     *\n     * @see {@link DeezerAlbum.partial}\n     */\n    releaseDate?: Date;\n    /**\n     * Whether the album is available\n     *\n     * `undefined` for partial albums\n     *\n     * @see {@link DeezerAlbum.partial}\n     */\n    available?: boolean;\n    /**\n     * The list of genres present in this album\n     *\n     * `undefined` for partial albums\n     *\n     * @see {@link DeezerAlbum.partial}\n     */\n    genres?: DeezerGenre[];\n    /**\n     * The contributors to the album\n     *\n     * `undefined` for partial albums\n     *\n     * @see {@link DeezerAlbum.partial}\n     */\n    contributors?: DeezerArtist[];\n\n    /**\n     * The list of tracks in the album\n     *\n     * empty (length === 0) for partial albums\n     *\n     * Use {@link DeezerAlbum.fetch} to populate the tracks and other properties\n     *\n     * @see {@link DeezerAlbum.partial}\n     */\n    tracks: DeezerTrack[];\n\n    /**\n     * Creates a Deezer album from the data in an API response\n     * @param data the data to use to create the album\n     * @param partial Whether the album should be partial\n     * @see {@link DeezerAlbum.partial}\n     */\n    constructor(data: any, partial: boolean) {\n        this.id = data.id;\n        this.title = data.title;\n        this.url = data.link;\n        this.recordType = data.record_type;\n        this.explicit = data.explicit_lyrics;\n        this.artist = new DeezerArtist(data.artist);\n        this.type = 'album';\n        this.tracksCount = data.nb_tracks;\n        this.contributors = [];\n        this.genres = [];\n        this.tracks = [];\n        this.cover = {\n            xl: data.cover_xl,\n            big: data.cover_big,\n            medium: data.cover_medium,\n            small: data.cover_small\n        };\n\n        this.partial = partial;\n\n        if (!partial) {\n            this.upc = data.upc;\n            this.durationInSec = data.duration;\n            this.numberOfFans = data.fans;\n            this.releaseDate = new Date(data.release_date);\n            this.available = data.available;\n\n            data.contributors.forEach((contributor: any) => {\n                this.contributors?.push(new DeezerArtist(contributor));\n            });\n\n            data.genres.data.forEach((genre: any) => {\n                this.genres?.push({\n                    name: genre.name,\n                    picture: {\n                        xl: `${genre.picture}?size=xl`,\n                        big: `${genre.picture}?size=big`,\n                        medium: `${genre.picture}?size=medium`,\n                        small: `${genre.picture}?size=small`\n                    }\n                });\n            });\n\n            const trackAlbum: any = {\n                id: this.id,\n                title: this.title,\n                cover_xl: this.cover.xl,\n                cover_big: this.cover.big,\n                cover_medium: this.cover.medium,\n                cover_small: this.cover.small,\n                release_date: data.release_date\n            };\n            data.tracks.data.forEach((track: any) => {\n                track.album = trackAlbum;\n                this.tracks.push(new DeezerTrack(track, true));\n            });\n        }\n    }\n\n    /**\n     * Fetches and populates the missing fields including all tracks.\n     *\n     * The property {@link DeezerAlbum.partial} will be `false` if this method finishes successfully.\n     *\n     * @returns A promise with the same album this method was called on.\n     */\n    async fetch(): Promise<DeezerAlbum> {\n        if (!this.partial) return this;\n\n        const response = await request(`https://api.deezer.com/album/${this.id}/`).catch((err: Error) => err);\n\n        if (response instanceof Error) throw response;\n        const jsonData = JSON.parse(response);\n\n        this.partial = false;\n\n        this.upc = jsonData.upc;\n        this.durationInSec = jsonData.duration;\n        this.numberOfFans = jsonData.fans;\n        this.releaseDate = new Date(jsonData.release_date);\n        this.available = jsonData.available;\n        this.contributors = [];\n        this.genres = [];\n        this.tracks = [];\n\n        jsonData.contributors.forEach((contributor: any) => {\n            this.contributors?.push(new DeezerArtist(contributor));\n        });\n\n        jsonData.genres.data.forEach((genre: any) => {\n            this.genres?.push({\n                name: genre.name,\n                picture: {\n                    xl: `${genre.picture}?size=xl`,\n                    big: `${genre.picture}?size=big`,\n                    medium: `${genre.picture}?size=medium`,\n                    small: `${genre.picture}?size=small`\n                }\n            });\n        });\n\n        const trackAlbum: any = {\n            id: this.id,\n            title: this.title,\n            cover_xl: this.cover.xl,\n            cover_big: this.cover.big,\n            cover_medium: this.cover.medium,\n            cover_small: this.cover.small,\n            release_date: jsonData.release_date\n        };\n        jsonData.tracks.data.forEach((track: any) => {\n            track.album = trackAlbum;\n            this.tracks.push(new DeezerTrack(track, true));\n        });\n\n        return this;\n    }\n    /**\n     * Fetches all the tracks in the album and returns them\n     *\n     * ```ts\n     * const album = await play.deezer('album url')\n     *\n     * const tracks = await album.all_tracks()\n     * ```\n     * @returns An array of {@link DeezerTrack}\n     */\n    async all_tracks(): Promise<DeezerTrack[]> {\n        await this.fetch();\n\n        return this.tracks as DeezerTrack[];\n    }\n    /**\n     * Converts instances of this class to JSON data\n     * @returns JSON data.\n     */\n    toJSON() {\n        return {\n            id: this.id,\n            title: this.title,\n            url: this.url,\n            recordType: this.recordType,\n            explicit: this.explicit,\n            artist: this.artist,\n            cover: this.cover,\n            type: this.type,\n            upc: this.upc,\n            tracksCount: this.tracksCount,\n            durationInSec: this.durationInSec,\n            numberOfFans: this.numberOfFans,\n            releaseDate: this.releaseDate,\n            available: this.available,\n            genres: this.genres,\n            contributors: this.contributors,\n            tracks: this.tracks.map((track) => track.toJSON())\n        };\n    }\n}\n/**\n * Class for Deezer Playlists\n */\nexport class DeezerPlaylist {\n    /**\n     * The id of the playlist\n     */\n    id: number;\n    /**\n     * The title of the playlist\n     */\n    title: string;\n    /**\n     * Whether the playlist is public or private\n     */\n    public: boolean;\n    /**\n     * The URL of the playlist on Deezer\n     */\n    url: string;\n    /**\n     * Cover picture of the playlist available in four sizes\n     */\n    picture: DeezerImage;\n    /**\n     * The date of the playlist's creation\n     */\n    creationDate: Date;\n    /**\n     * The type, always `'playlist'`, useful to determine what the deezer function returned\n     */\n    type: 'track' | 'playlist' | 'album';\n    /**\n     * The Deezer user that created the playlist\n     */\n    creator: DeezerUser;\n    /**\n     * The number of tracks in the playlist\n     */\n    tracksCount: number;\n\n    /**\n     * Signifies that some properties are not populated\n     *\n     * Partial playlists can be populated by calling {@link DeezerPlaylist.fetch}.\n     *\n     * `true` for playlists in search results and `false` if the album was fetched directly or expanded.\n     */\n    partial: boolean;\n\n    /**\n     * Description of the playlist\n     *\n     * `undefined` for partial playlists\n     *\n     * @see {@link DeezerPlaylist.partial}\n     */\n    description?: string;\n    /**\n     * Duration of the playlist in seconds\n     *\n     * `undefined` for partial playlists\n     *\n     * @see {@link DeezerPlaylist.partial}\n     */\n    durationInSec?: number;\n    /**\n     * `true` if the playlist is the loved tracks playlist\n     *\n     * `undefined` for partial playlists\n     *\n     * @see {@link DeezerPlaylist.partial}\n     */\n    isLoved?: boolean;\n    /**\n     * Whether multiple users have worked on the playlist\n     *\n     * `undefined` for partial playlists\n     *\n     * @see {@link DeezerPlaylist.partial}\n     */\n    collaborative?: boolean;\n    /**\n     * The number of fans the playlist has\n     *\n     * `undefined` for partial playlists\n     *\n     * @see {@link DeezerPlaylist.partial}\n     */\n    fans?: number;\n\n    /**\n     * The list of tracks in the playlist\n     *\n     * empty (length === 0) for partial and non public playlists\n     *\n     * Use {@link DeezerPlaylist.fetch} to populate the tracks and other properties\n     *\n     * @see {@link DeezerPlaylist.partial}\n     * @see {@link DeezerPlaylist.public}\n     */\n    tracks: DeezerTrack[];\n\n    /**\n     * Creates a Deezer playlist from the data in an API response\n     * @param data the data to use to create the playlist\n     * @param partial Whether the playlist should be partial\n     * @see {@link DeezerPlaylist.partial}\n     */\n    constructor(data: any, partial: boolean) {\n        this.id = data.id;\n        this.title = data.title;\n        this.public = data.public;\n        this.url = data.link;\n        this.creationDate = new Date(data.creation_date);\n        this.type = 'playlist';\n        this.tracksCount = data.nb_tracks;\n        this.tracks = [];\n\n        this.picture = {\n            xl: data.picture_xl,\n            big: data.picture_big,\n            medium: data.picture_medium,\n            small: data.picture_small\n        };\n\n        if (data.user) {\n            this.creator = {\n                id: data.user.id,\n                name: data.user.name\n            };\n        } else {\n            this.creator = {\n                id: data.creator.id,\n                name: data.creator.name\n            };\n        }\n\n        this.partial = partial;\n\n        if (!partial) {\n            this.description = data.description;\n            this.durationInSec = data.duration;\n            this.isLoved = data.is_loved_track;\n            this.collaborative = data.collaborative;\n            this.fans = data.fans;\n\n            if (this.public) {\n                this.tracks = data.tracks.data.map((track: any) => {\n                    return new DeezerTrack(track, true);\n                });\n            }\n        }\n    }\n\n    /**\n     * Fetches and populates the missing fields, including all tracks.\n     *\n     * The property {@link DeezerPlaylist.partial} will be `false` if this method finishes successfully.\n     *\n     * @returns A promise with the same playlist this method was called on.\n     */\n    async fetch(): Promise<DeezerPlaylist> {\n        if (!this.partial && (this.tracks.length === this.tracksCount || !this.public)) {\n            return this;\n        }\n\n        if (this.partial) {\n            const response = await request(`https://api.deezer.com/playlist/${this.id}/`).catch((err: Error) => err);\n\n            if (response instanceof Error) throw response;\n            const jsonData = JSON.parse(response);\n\n            this.partial = false;\n\n            this.description = jsonData.description;\n            this.durationInSec = jsonData.duration;\n            this.isLoved = jsonData.is_loved_track;\n            this.collaborative = jsonData.collaborative;\n            this.fans = jsonData.fans;\n\n            if (this.public) {\n                this.tracks = jsonData.tracks.data.map((track: any) => {\n                    return new DeezerTrack(track, true);\n                });\n            }\n        }\n\n        const currentTracksCount = this.tracks.length;\n        if (this.public && currentTracksCount !== this.tracksCount) {\n            let missing = this.tracksCount - currentTracksCount;\n\n            if (missing > 1000) missing = 1000;\n\n            const promises: Promise<DeezerTrack[]>[] = [];\n            for (let i = 1; i <= Math.ceil(missing / 100); i++) {\n                promises.push(\n                    new Promise(async (resolve, reject) => {\n                        const response = await request(\n                            `https://api.deezer.com/playlist/${this.id}/tracks?limit=100&index=${i * 100}`\n                        ).catch((err) => reject(err));\n\n                        if (typeof response !== 'string') return;\n                        const jsonData = JSON.parse(response);\n                        const tracks = jsonData.data.map((track: any) => {\n                            return new DeezerTrack(track, true);\n                        });\n\n                        resolve(tracks);\n                    })\n                );\n            }\n\n            const results = await Promise.allSettled(promises);\n            const newTracks: DeezerTrack[] = [];\n\n            for (const result of results) {\n                if (result.status === 'fulfilled') {\n                    newTracks.push(...result.value);\n                } else {\n                    throw result.reason;\n                }\n            }\n\n            this.tracks.push(...newTracks);\n        }\n\n        return this;\n    }\n    /**\n     * Fetches all the tracks in the playlist and returns them\n     *\n     * ```ts\n     * const playlist = await play.deezer('playlist url')\n     *\n     * const tracks = await playlist.all_tracks()\n     * ```\n     * @returns An array of {@link DeezerTrack}\n     */\n    async all_tracks(): Promise<DeezerTrack[]> {\n        await this.fetch();\n\n        return this.tracks as DeezerTrack[];\n    }\n    /**\n     * Converts instances of this class to JSON data\n     * @returns JSON data.\n     */\n    toJSON() {\n        return {\n            id: this.id,\n            title: this.title,\n            public: this.public,\n            url: this.url,\n            picture: this.picture,\n            creationDate: this.creationDate,\n            type: this.type,\n            creator: this.creator,\n            tracksCount: this.tracksCount,\n            description: this.description,\n            durationInSec: this.durationInSec,\n            isLoved: this.isLoved,\n            collaborative: this.collaborative,\n            fans: this.fans,\n            tracks: this.tracks.map((track) => track.toJSON())\n        };\n    }\n}\n\nclass DeezerTrackAlbum {\n    id: number;\n    title: string;\n    url: string;\n    cover: DeezerImage;\n    releaseDate?: Date;\n\n    constructor(data: any) {\n        this.id = data.id;\n        this.title = data.title;\n        this.url = `https://www.deezer.com/album/${data.id}/`;\n        this.cover = {\n            xl: data.cover_xl,\n            big: data.cover_big,\n            medium: data.cover_medium,\n            small: data.cover_small\n        };\n\n        if (data.release_date) this.releaseDate = new Date(data.release_date);\n    }\n}\n/**\n * Class representing a Deezer artist\n */\nclass DeezerArtist {\n    /**\n     * The id of the artist\n     */\n    id: number;\n    /**\n     * The name of the artist\n     */\n    name: string;\n    /**\n     * The URL of the artist on Deezer\n     */\n    url: string;\n\n    /**\n     * The picture of the artist available in four sizes\n     */\n    picture?: DeezerImage;\n    /**\n     * The of the artist on the track\n     */\n    role?: string;\n\n    constructor(data: any) {\n        this.id = data.id;\n        this.name = data.name;\n\n        this.url = data.link ? data.link : `https://www.deezer.com/artist/${data.id}/`;\n\n        if (data.picture_xl)\n            this.picture = {\n                xl: data.picture_xl,\n                big: data.picture_big,\n                medium: data.picture_medium,\n                small: data.picture_small\n            };\n\n        if (data.role) this.role = data.role;\n    }\n}\n","import { setUserAgent } from './Request/useragent';\nimport { setSoundCloudToken } from './SoundCloud';\nimport { setSpotifyToken } from './Spotify';\nimport { setCookieToken } from './YouTube/utils/cookie';\n\ninterface tokenOptions {\n    spotify?: {\n        client_id: string;\n        client_secret: string;\n        refresh_token: string;\n        market: string;\n    };\n    soundcloud?: {\n        client_id: string;\n    };\n    youtube?: {\n        cookie: string;\n    };\n    useragent?: string[];\n}\n/**\n * Sets\n *\n *  i> YouTube :- cookies.\n *\n *  ii> SoundCloud :- client ID.\n *\n *  iii> Spotify :- client ID, client secret, refresh token, market.\n *\n *  iv> Useragents :- array of string.\n *\n * locally in memory.\n *\n * Example :\n * ```ts\n * play.setToken({\n *      youtube : {\n *          cookie : \"Your Cookies\"\n *      }\n * }) // YouTube Cookies\n *\n * await play.setToken({\n *      spotify : {\n *          client_id: 'ID',\n            client_secret: 'secret',\n            refresh_token: 'token',\n            market: 'US'\n *      }\n * }) // Await this only when setting data for spotify\n * \n * play.setToken({\n *      useragent: ['Your User-agent']\n * }) // Use this to avoid 429 errors.\n * ```\n * @param options {@link tokenOptions}\n */\nexport async function setToken(options: tokenOptions) {\n    if (options.spotify) await setSpotifyToken(options.spotify);\n    if (options.soundcloud) setSoundCloudToken(options.soundcloud);\n    if (options.youtube) setCookieToken(options.youtube);\n    if (options.useragent) setUserAgent(options.useragent);\n}\n","import {\n    playlist_info,\n    video_basic_info,\n    video_info,\n    decipher_info,\n    yt_validate,\n    extractID,\n    YouTube,\n    YouTubeStream,\n    YouTubeChannel,\n    YouTubePlayList,\n    YouTubeVideo,\n    InfoData\n} from './YouTube';\nimport {\n    spotify,\n    sp_validate,\n    refreshToken,\n    is_expired,\n    SpotifyAlbum,\n    SpotifyPlaylist,\n    SpotifyTrack,\n    Spotify,\n    SpotifyAuthorize,\n    sp_search\n} from './Spotify';\nimport {\n    soundcloud,\n    so_validate,\n    SoundCloud,\n    SoundCloudStream,\n    getFreeClientID,\n    SoundCloudPlaylist,\n    SoundCloudTrack,\n    check_id,\n    so_search,\n    stream as so_stream,\n    stream_from_info as so_stream_info\n} from './SoundCloud';\nimport {\n    deezer,\n    dz_validate,\n    dz_advanced_track_search,\n    Deezer,\n    DeezerTrack,\n    DeezerPlaylist,\n    DeezerAlbum,\n    dz_search\n} from './Deezer';\nimport { setToken } from './token';\n\nenum AudioPlayerStatus {\n    Idle = 'idle',\n    Buffering = 'buffering',\n    Paused = 'paused',\n    Playing = 'playing',\n    AutoPaused = 'autopaused'\n}\n\ninterface SearchOptions {\n    limit?: number;\n    source?: {\n        youtube?: 'video' | 'playlist' | 'channel';\n        spotify?: 'album' | 'playlist' | 'track';\n        soundcloud?: 'tracks' | 'playlists' | 'albums';\n        deezer?: 'track' | 'playlist' | 'album';\n    };\n    fuzzy?: boolean;\n    language?: string;\n    /**\n     * !!! Before enabling this for public servers, please consider using Discord features like NSFW channels as not everyone in your server wants to see NSFW images. !!!\n     * Unblurred images will likely have different dimensions than specified in the {@link YouTubeThumbnail} objects.\n     */\n    unblurNSFWThumbnails?: boolean;\n}\n\nimport { createInterface } from 'node:readline';\nimport { existsSync, mkdirSync, writeFileSync } from 'node:fs';\nimport { stream as yt_stream, StreamOptions, stream_from_info as yt_stream_info } from './YouTube/stream';\nimport { yt_search } from './YouTube/search';\nimport { EventEmitter } from 'stream';\n\nasync function stream(url: string, options: { seek?: number } & StreamOptions): Promise<YouTubeStream>;\nasync function stream(url: string, options?: StreamOptions): Promise<YouTubeStream | SoundCloudStream>;\n/**\n * Creates a Stream [ YouTube or SoundCloud ] class from a url for playing.\n *\n * Example\n * ```ts\n * const source = await play.stream('youtube video URL') // YouTube Video Stream\n *\n * const source = await play.stream('soundcloud track URL') // SoundCloud Track Stream\n *\n * const source = await play.stream('youtube video URL', { seek : 45 }) // Seeks 45 seconds (approx.) in YouTube Video Stream\n *\n * const resource = createAudioResource(source.stream, {\n *      inputType : source.type\n * }) // Use discordjs voice createAudioResource function.\n * ```\n * @param url Video / Track URL\n * @param options\n *\n *  - `number` seek : No of seconds to seek in stream.\n *  - `string` language : Sets language of searched content [ YouTube search only. ], e.g. \"en-US\"\n *  - `number` quality : Quality number. [ 0 = Lowest, 1 = Medium, 2 = Highest ]\n *  - `boolean` htmldata : given data is html data or not\n *  - `number` precache : No of segments of data to store before looping [YouTube Live Stream only]. [ Defaults to 3 ]\n *  - `boolean` discordPlayerCompatibility : Conversion of Webm to Opus [ Defaults to false ]\n * @returns A {@link YouTubeStream} or {@link SoundCloudStream} Stream to play\n */\nasync function stream(url: string, options: StreamOptions = {}): Promise<YouTubeStream | SoundCloudStream> {\n    const url_ = url.trim();\n    if (url_.length === 0) throw new Error('Stream URL has a length of 0. Check your url again.');\n    if (options.htmldata) return await yt_stream(url_, options);\n    if (url_.indexOf('spotify') !== -1) {\n        throw new Error(\n            'Streaming from Spotify is not supported. Please use search() to find a similar track on YouTube or SoundCloud instead.'\n        );\n    }\n    if (url_.indexOf('deezer') !== -1) {\n        throw new Error(\n            'Streaming from Deezer is not supported. Please use search() to find a similar track on YouTube or SoundCloud instead.'\n        );\n    }\n    if (url_.indexOf('soundcloud') !== -1) return await so_stream(url_, options.quality);\n    else return await yt_stream(url_, options);\n}\n\nasync function search(query: string, options: { source: { deezer: 'album' } } & SearchOptions): Promise<DeezerAlbum[]>;\nasync function search(\n    query: string,\n    options: { source: { deezer: 'playlist' } } & SearchOptions\n): Promise<DeezerPlaylist[]>;\nasync function search(query: string, options: { source: { deezer: 'track' } } & SearchOptions): Promise<DeezerTrack[]>;\nasync function search(\n    query: string,\n    options: { source: { soundcloud: 'albums' } } & SearchOptions\n): Promise<SoundCloudPlaylist[]>;\nasync function search(\n    query: string,\n    options: { source: { soundcloud: 'playlists' } } & SearchOptions\n): Promise<SoundCloudPlaylist[]>;\nasync function search(\n    query: string,\n    options: { source: { soundcloud: 'tracks' } } & SearchOptions\n): Promise<SoundCloudTrack[]>;\nasync function search(\n    query: string,\n    options: { source: { spotify: 'album' } } & SearchOptions\n): Promise<SpotifyAlbum[]>;\nasync function search(\n    query: string,\n    options: { source: { spotify: 'playlist' } } & SearchOptions\n): Promise<SpotifyPlaylist[]>;\nasync function search(\n    query: string,\n    options: { source: { spotify: 'track' } } & SearchOptions\n): Promise<SpotifyTrack[]>;\nasync function search(\n    query: string,\n    options: { source: { youtube: 'channel' } } & SearchOptions\n): Promise<YouTubeChannel[]>;\nasync function search(\n    query: string,\n    options: { source: { youtube: 'playlist' } } & SearchOptions\n): Promise<YouTubePlayList[]>;\nasync function search(\n    query: string,\n    options: { source: { youtube: 'video' } } & SearchOptions\n): Promise<YouTubeVideo[]>;\nasync function search(query: string, options: { limit: number } & SearchOptions): Promise<YouTubeVideo[]>;\nasync function search(query: string, options?: SearchOptions): Promise<YouTubeVideo[]>;\n/**\n * Searches through a particular source and gives respective info.\n * \n * Example\n * ```ts\n * const searched = await play.search('Rick Roll', { source : { youtube : \"video\" } }) // YouTube Video Search\n * \n * const searched = await play.search('Rick Roll', { limit : 1 }) // YouTube Video Search but returns only 1 video.\n * \n * const searched = await play.search('Rick Roll', { source : { spotify : \"track\" } }) // Spotify Track Search\n * \n * const searched = await play.search('Rick Roll', { source : { soundcloud : \"tracks\" } }) // SoundCloud Track Search\n * \n * const searched = await play.search('Rick Roll', { source : { deezer : \"track\" } }) // Deezer Track Search\n * ```\n * @param query string to search.\n * @param options\n * \n *  - `number` limit : No of searches you want to have.\n *  - `string` language : Sets language of searched content [ YouTube search only. ], e.g. \"en-US\"\n *  - `boolean` unblurNSFWThumbnails : Unblurs NSFW thumbnails. Defaults to `false` [ YouTube search only. ]\n *              !!! Before enabling this for public servers, please consider using Discord features like NSFW channels as not everyone in your server wants to see NSFW images. !!!\n *              Unblurred images will likely have different dimensions than specified in the {@link YouTubeThumbnail} objects.\n *  - `boolean` fuzzy : Whether the search should be fuzzy or only return exact matches. Defaults to `true`. [ for `Deezer` Only ]\n *  - `Object` source : Contains type of source and type of result you want to have\n * ```ts\n *      - youtube : 'video' | 'playlist' | 'channel';\n        - spotify : 'album' | 'playlist' | 'track';\n        - soundcloud : 'tracks' | 'playlists' | 'albums';\n        - deezer : 'track' | 'playlist' | 'album';\n    ```\n * @returns Array of {@link YouTube} or {@link Spotify} or {@link SoundCloud} or {@link Deezer} type\n */\nasync function search(\n    query: string,\n    options: SearchOptions = {}\n): Promise<YouTube[] | Spotify[] | SoundCloud[] | Deezer[]> {\n    if (!options.source) options.source = { youtube: 'video' };\n    const query_ = encodeURIComponent(query.trim());\n    if (options.source.youtube)\n        return await yt_search(query_, {\n            limit: options.limit,\n            type: options.source.youtube,\n            language: options.language,\n            unblurNSFWThumbnails: options.unblurNSFWThumbnails\n        });\n    else if (options.source.spotify) return await sp_search(query_, options.source.spotify, options.limit);\n    else if (options.source.soundcloud) return await so_search(query_, options.source.soundcloud, options.limit);\n    else if (options.source.deezer)\n        return await dz_search(query_, { limit: options.limit, type: options.source.deezer, fuzzy: options.fuzzy });\n    else throw new Error('Not possible to reach Here LOL. Easter Egg of play-dl if someone get this.');\n}\n\nasync function stream_from_info(info: SoundCloudTrack, options?: StreamOptions): Promise<SoundCloudStream>;\nasync function stream_from_info(info: InfoData, options?: StreamOptions): Promise<YouTubeStream>;\n/**\n * Creates a Stream [ YouTube or SoundCloud ] class from video or track info for playing.\n *\n * Example\n * ```ts\n * const info = await video_info('youtube URL')\n * const source = await play.stream_from_info(info) // YouTube Video Stream\n *\n * const soundInfo = await play.soundcloud('SoundCloud URL')\n * const source = await play.stream_from_info(soundInfo) // SoundCloud Track Stream\n *\n * const source = await play.stream_from_info(info, { seek : 45 }) // Seeks 45 seconds (approx.) in YouTube Video Stream\n *\n * const resource = createAudioResource(source.stream, {\n *      inputType : source.type\n * }) // Use discordjs voice createAudioResource function.\n * ```\n * @param info YouTube video info OR SoundCloud track Class\n * @param options\n *\n *  - `number` seek : No of seconds to seek in stream.\n *  - `string` language : Sets language of searched content [ YouTube search only. ], e.g. \"en-US\"\n *  - `number` quality : Quality number. [ 0 = Lowest, 1 = Medium, 2 = Highest ]\n *  - `boolean` htmldata : given data is html data or not\n *  - `number` precache : No of segments of data to store before looping [YouTube Live Stream only]. [ Defaults to 3 ]\n *  - `boolean` discordPlayerCompatibility : Conversion of Webm to Opus[ Defaults to false ]\n * @returns A {@link YouTubeStream} or {@link SoundCloudStream} Stream to play\n */\nasync function stream_from_info(\n    info: InfoData | SoundCloudTrack,\n    options: StreamOptions = {}\n): Promise<YouTubeStream | SoundCloudStream> {\n    if (info instanceof SoundCloudTrack) return await so_stream_info(info, options.quality);\n    else return await yt_stream_info(info, options);\n}\n/**\n * Validates url that play-dl supports.\n *\n * - `so` - SoundCloud\n * - `sp` - Spotify\n * - `dz` - Deezer\n * - `yt` - YouTube\n * @param url URL\n * @returns\n * ```ts\n * 'so_playlist' / 'so_track' | 'sp_track' | 'sp_album' | 'sp_playlist' | 'dz_track' | 'dz_playlist' | 'dz_album' | 'yt_video' | 'yt_playlist' | 'search' | false\n * ```\n */\nasync function validate(\n    url: string\n): Promise<\n    | 'so_playlist'\n    | 'so_track'\n    | 'sp_track'\n    | 'sp_album'\n    | 'sp_playlist'\n    | 'dz_track'\n    | 'dz_playlist'\n    | 'dz_album'\n    | 'yt_video'\n    | 'yt_playlist'\n    | 'search'\n    | false\n> {\n    let check;\n    const url_ = url.trim();\n    if (!url_.startsWith('https')) return 'search';\n    if (url_.indexOf('spotify') !== -1) {\n        check = sp_validate(url_);\n        return check !== false ? (('sp_' + check) as 'sp_track' | 'sp_album' | 'sp_playlist') : false;\n    } else if (url_.indexOf('soundcloud') !== -1) {\n        check = await so_validate(url_);\n        return check !== false ? (('so_' + check) as 'so_playlist' | 'so_track') : false;\n    } else if (url_.indexOf('deezer') !== -1) {\n        check = await dz_validate(url_);\n        return check !== false ? (('dz_' + check) as 'dz_track' | 'dz_playlist' | 'dz_album') : false;\n    } else {\n        check = yt_validate(url_);\n        return check !== false ? (('yt_' + check) as 'yt_video' | 'yt_playlist') : false;\n    }\n}\n/**\n * Authorization interface for Spotify, SoundCloud and YouTube.\n *\n * Either stores info in `.data` folder or shows relevant data to be used in `setToken` function.\n *\n * ```ts\n * const play = require('play-dl')\n *\n * play.authorization()\n * ```\n *\n * Just run the above command and you will get a interface asking some questions.\n */\nfunction authorization(): void {\n    const ask = createInterface({\n        input: process.stdin,\n        output: process.stdout\n    });\n    ask.question('Do you want to save data in a file ? (Yes / No): ', (msg) => {\n        let file: boolean;\n        if (msg.toLowerCase() === 'yes') file = true;\n        else if (msg.toLowerCase() === 'no') file = false;\n        else {\n            console.log(\"That option doesn't exist. Try again...\");\n            ask.close();\n            return;\n        }\n        ask.question('Choose your service - sc (for SoundCloud) / sp (for Spotify)  / yo (for YouTube): ', (msg) => {\n            if (msg.toLowerCase().startsWith('sp')) {\n                let client_id: string, client_secret: string, redirect_url: string, market: string;\n                ask.question('Start by entering your Client ID : ', (id) => {\n                    client_id = id;\n                    ask.question('Now enter your Client Secret : ', (secret) => {\n                        client_secret = secret;\n                        ask.question('Enter your Redirect URL now : ', (url) => {\n                            redirect_url = url;\n                            console.log(\n                                '\\nIf you would like to know your region code visit : \\nhttps://en.wikipedia.org/wiki/ISO_3166-1_alpha-2#Officially_assigned_code_elements \\n'\n                            );\n                            ask.question('Enter your region code (2-letter country code) : ', (mar) => {\n                                if (mar.length === 2) market = mar;\n                                else {\n                                    console.log(\n                                        \"That doesn't look like a valid region code, IN will be selected as default.\"\n                                    );\n                                    market = 'IN';\n                                }\n                                console.log(\n                                    '\\nNow open your browser and paste the below url, then authorize it and copy the redirected url. \\n'\n                                );\n                                console.log(\n                                    `https://accounts.spotify.com/authorize?client_id=${client_id}&response_type=code&redirect_uri=${encodeURI(\n                                        redirect_url\n                                    )} \\n`\n                                );\n                                ask.question('Paste the url which you just copied : ', async (url) => {\n                                    if (!existsSync('.data')) mkdirSync('.data');\n                                    const spotifyData = {\n                                        client_id,\n                                        client_secret,\n                                        redirect_url,\n                                        authorization_code: url.split('code=')[1],\n                                        market\n                                    };\n                                    const check = await SpotifyAuthorize(spotifyData, file);\n                                    if (check === false) throw new Error('Failed to get access token.');\n                                    ask.close();\n                                });\n                            });\n                        });\n                    });\n                });\n            } else if (msg.toLowerCase().startsWith('sc')) {\n                if (!file) {\n                    console.log('You already had a client ID, just paste that in setToken function.');\n                    ask.close();\n                    return;\n                }\n                ask.question('Client ID : ', async (id) => {\n                    let client_id = id;\n                    if (!client_id) {\n                        console.log(\"You didn't provide a client ID. Try again...\");\n                        ask.close();\n                        return;\n                    }\n                    if (!existsSync('.data')) mkdirSync('.data');\n                    console.log('Validating your client ID, hold on...');\n                    if (await check_id(client_id)) {\n                        console.log('Client ID has been validated successfully.');\n                        writeFileSync('.data/soundcloud.data', JSON.stringify({ client_id }, undefined, 4));\n                    } else console.log(\"That doesn't look like a valid client ID. Retry with a correct client ID.\");\n                    ask.close();\n                });\n            } else if (msg.toLowerCase().startsWith('yo')) {\n                if (!file) {\n                    console.log('You already had cookie, just paste that in setToken function.');\n                    ask.close();\n                    return;\n                }\n                ask.question('Cookies : ', (cook: string) => {\n                    if (!cook || cook.length === 0) {\n                        console.log(\"You didn't provide a cookie. Try again...\");\n                        ask.close();\n                        return;\n                    }\n                    if (!existsSync('.data')) mkdirSync('.data');\n                    console.log('Cookies has been added successfully.');\n                    let cookie: Object = {};\n                    cook.split(';').forEach((x) => {\n                        const arr = x.split('=');\n                        if (arr.length <= 1) return;\n                        const key = arr.shift()?.trim() as string;\n                        const value = arr.join('=').trim();\n                        Object.assign(cookie, { [key]: value });\n                    });\n                    writeFileSync('.data/youtube.data', JSON.stringify({ cookie }, undefined, 4));\n                    ask.close();\n                });\n            } else {\n                console.log(\"That option doesn't exist. Try again...\");\n                ask.close();\n            }\n        });\n    });\n}\n/**\n * Attaches paused, playing, autoPaused Listeners to discordjs voice AudioPlayer.\n *\n * Useful if you don't want extra data to be downloaded by play-dl.\n * @param player discordjs voice AudioPlayer\n * @param resource A {@link YouTubeStream} or {@link SoundCloudStream}\n */\nfunction attachListeners(player: EventEmitter, resource: YouTubeStream | SoundCloudStream) {\n    // cleanup existing listeners if they are still registered\n    type listenerType = (...args: any[]) => void;\n\n    const listeners = player.listeners(AudioPlayerStatus.Idle);\n    for (const cleanup of listeners) {\n        if ((cleanup as any).__playDlAttachedListener) {\n            cleanup();\n            player.removeListener(AudioPlayerStatus.Idle, cleanup as listenerType);\n        }\n    }\n\n    const pauseListener = () => resource.pause();\n    const resumeListener = () => resource.resume();\n    const idleListener = () => {\n        player.removeListener(AudioPlayerStatus.Paused, pauseListener);\n        player.removeListener(AudioPlayerStatus.AutoPaused, pauseListener);\n        player.removeListener(AudioPlayerStatus.Playing, resumeListener);\n    };\n    pauseListener.__playDlAttachedListener = true;\n    resumeListener.__playDlAttachedListener = true;\n    idleListener.__playDlAttachedListener = true;\n    player.on(AudioPlayerStatus.Paused, pauseListener);\n    player.on(AudioPlayerStatus.AutoPaused, pauseListener);\n    player.on(AudioPlayerStatus.Playing, resumeListener);\n    player.once(AudioPlayerStatus.Idle, idleListener);\n}\n\n// Export Main Commands\nexport {\n    DeezerAlbum,\n    DeezerPlaylist,\n    DeezerTrack,\n    SoundCloudPlaylist,\n    SoundCloudStream,\n    SoundCloudTrack,\n    SpotifyAlbum,\n    SpotifyPlaylist,\n    SpotifyTrack,\n    YouTubeChannel,\n    YouTubePlayList,\n    YouTubeVideo,\n    attachListeners,\n    authorization,\n    decipher_info,\n    deezer,\n    dz_advanced_track_search,\n    dz_validate,\n    extractID,\n    getFreeClientID,\n    is_expired,\n    playlist_info,\n    refreshToken,\n    search,\n    setToken,\n    so_validate,\n    soundcloud,\n    spotify,\n    sp_validate,\n    stream,\n    stream_from_info,\n    validate,\n    video_basic_info,\n    video_info,\n    yt_validate,\n    InfoData\n};\n\n// Export Types\nexport { Deezer, YouTube, SoundCloud, Spotify, YouTubeStream };\n\n// Export Default\nexport default {\n    DeezerAlbum,\n    DeezerPlaylist,\n    DeezerTrack,\n    SoundCloudPlaylist,\n    SoundCloudStream,\n    SoundCloudTrack,\n    SpotifyAlbum,\n    SpotifyPlaylist,\n    SpotifyTrack,\n    YouTubeChannel,\n    YouTubePlayList,\n    YouTubeVideo,\n    attachListeners,\n    authorization,\n    decipher_info,\n    deezer,\n    dz_advanced_track_search,\n    dz_validate,\n    extractID,\n    getFreeClientID,\n    is_expired,\n    playlist_info,\n    refreshToken,\n    search,\n    setToken,\n    so_validate,\n    soundcloud,\n    spotify,\n    sp_validate,\n    stream,\n    stream_from_info,\n    validate,\n    video_basic_info,\n    video_info,\n    yt_validate\n};\n"],"mappings":"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","names":["httpsRequest","URL","createGunzip","createBrotliDecompress","createDeflate","existsSync","readFileSync","writeFileSync","youtubeData","existsSync","readFileSync","getCookies","result","key","value","__name","setCookie","uploadCookie","writeFileSync","setCookieToken","options","cook","cookie","x","arr","cookieHeaders","headCookie","z","setUserAgent","array","useragents_default","__name","getRandomInt","min","max","getRandomUserAgent","random","request_stream","req_url","options","resolve","reject","res","https_getter","err","__name","internalRequest","request","cookies_added","cook","getCookies","cookies","cookie","existingCookies","getRandomUserAgent","parts","cookieHeaders","data","decoder","encoding","createGunzip","createBrotliDecompress","createDeflate","c","request_resolve_redirect","url","statusCode","resolved","request_content_length","newURL","res2","URL","req_options","req","httpsRequest","Readable","URL","URLSearchParams","var_js","singlequote_js","duoblequote_js","quote_js","key_js","prop_js","empty_js","reverse_function","slice_function","splice_function","swap_function","obj_regexp","function_regexp","reverse_regexp","slice_regexp","splice_regexp","swap_regexp","js_tokens","body","function_action","object_action","object","object_body","function_body","result","reverseKey","sliceKey","spliceKey","swapKey","keys","myreg","tokenizeRegexp","tokens","__name","deciper_signature","signature","sig","len","i","token","pos","swappositions","array","position","first","download_url","format","decoded_url","parsed_url","URL","format_decipher","formats","html5player","request","cipher","params","URLSearchParams","YouTubeChannel","data","options","def","__name","YouTubeThumbnail","data","__name","YouTubeVideo","data","thumbnails","thumb","YouTubeThumbnail","YouTubeChannel","__name","BASE_API","YouTubePlayList","data","searchResult","YouTubeChannel","YouTubeThumbnail","limit","nextPage","request","contents","playlist_videos","getPlaylistVideos","getContinuationToken","max","res","number","page_number","videos","page","__name","URL","URLSearchParams","video_id_pattern","playlist_id_pattern","DEFAULT_API_KEY","video_pattern","playlist_pattern","yt_validate","url","url_","id","__name","extractVideoId","urlOrId","extractID","check","video_id","video_basic_info","options","body","cookieJar","new_url","request","player_data","initial_data","player_response","initial_response","vid","discretionAdvised","upcoming","cookies","updatedValues","acceptViewerDiscretion","ownerInfo","badge","html5player","related","res","x","microformat","musicInfo","music","row","title","contents","rawChapters","m","chapters","chapterRenderer","parseSeconds","upcomingDate","timestamp","video_details","YouTubeVideo","content","button","format","parseAudioFormats","getAndroidFormats","video_stream_info","duration","LiveStreamData","decipher_info","seconds","d","h","hDisplay","mDisplay","sDisplay","video_info","data","audio_only","format_decipher","playlist_info","urlObj","URL","response","getWatchPlaylist","getNormalPlaylist","getPlaylistVideos","limit","videos","i","info","getContinuationToken","videoId","extractRelated","apiKey","sessionToken","verificationResponse","endpoint","videoPage","URLSearchParams","videoPageData","streamingData","playlist_details","getWatchPlaylistVideos","API_KEY","videoCount","channel","YouTubePlayList","json_data","author","views","lastUpdate","y","videosCount","channel_info","parseDuration","text","split","URL","LiveStream","dash_url","interval","video_url","precache","Readable","Timer","info","video_stream_info","audioFormat","request","request_stream","URL","list","len","i","resolve","stream","err","c","__name","Stream","url","type","duration","contentLength","options","parseAudioFormats","end","chunk","callback","time","WebmElements","WebmHeader","Duplex","WEB_ELEMENT_KEYS","WebmElements","WebmSeeker","Duplex","sec","options","WebmHeader","i","length","value","content_length","clusterlength","position","time_left","data","chunk","_","callback","err","oldCursor","id","ebmlID","parse","track","positionFound","error","__name","SeekStream","url","duration","headerLength","contentLength","bitrate","video_url","options","WebmSeeker","Timer","parse","res","rej","stream","request_stream","err","bytes","info","video_stream_info","audioFormat","parseAudioFormats","end","chunk","__name","URL","parseAudioFormats","formats","result","format","type","__name","stream","url","options","info","video_stream_info","stream_from_info","final","LiveStream","audioFormat","request_stream","URL","SeekStream","contentLength","request_content_length","Stream","BLURRED_THUMBNAILS","ParseSearchResult","html","options","hasLimit","data","json_data","results","details","s","detail","parsed","parseVideo","unblurThumbnail","parseChannel","parsePlaylist","__name","parseDuration","duration","args","dur","badge","url","thumbnail","YouTubeChannel","channel","durationText","YouTubeVideo","run","YouTubePlayList","sqp","yt_search","search","options","url","body","request","ParseSearchResult","__name","SpotifyTrack","data","artists","v","__name","SpotifyPlaylist","spotifyData","search","videos","fetching","work","i","resolve","reject","response","request","err","num","page_number","tracks","page","SpotifyAlbum","existsSync","readFileSync","writeFileSync","spotifyData","existsSync","readFileSync","pattern","spotify","url","url_","trackID","response","request","err","SpotifyTrack","albumID","SpotifyAlbum","playlistID","SpotifyPlaylist","__name","sp_validate","SpotifyAuthorize","data","file","resp_json","writeFileSync","is_expired","sp_search","query","type","limit","results","json_data","track","album","playlist","refreshToken","setSpotifyToken","options","existsSync","readFileSync","Readable","SoundCloudTrack","data","__name","SoundCloudPlaylist","client_id","tracks","track","work","i","resolve","num","request","count","SoundCloudStream","url","type","Readable","Timer","response","err","val","stream","request_stream","c","soundData","existsSync","readFileSync","pattern","soundcloud","url","url_","data","request","err","json_data","SoundCloudTrack","SoundCloudPlaylist","__name","so_search","query","type","limit","response","results","x","stream","quality","HLSformats","parseHlsFormats","req_url","s_data","SoundCloudStream","getFreeClientID","splitted","urls","r","stream_from_info","check_id","id","so_validate","result","format","setSoundCloudToken","options","URL","DeezerTrack","data","partial","DeezerArtist","DeezerTrackAlbum","contributor","response","request","err","jsonData","__name","DeezerAlbum","genre","trackAlbum","track","DeezerPlaylist","currentTracksCount","missing","promises","i","resolve","reject","tracks","results","newTracks","result","internalValidate","url","urlObj","URL","pathname","path","resolved","request_resolve_redirect","err","__name","deezer","typeData","response","request","jsonData","DeezerTrack","DeezerPlaylist","DeezerAlbum","dz_validate","dz_search","query","options","query_","type","limit","fuzzy","results","track","playlist","album","dz_advanced_track_search","metadata","setToken","options","setSpotifyToken","setSoundCloudToken","setCookieToken","setUserAgent","__name","createInterface","existsSync","mkdirSync","writeFileSync","stream","url","options","url_","__name","search","query","query_","yt_search","sp_search","so_search","dz_search","stream_from_info","info","SoundCloudTrack","validate","check","sp_validate","so_validate","dz_validate","yt_validate","authorization","ask","createInterface","msg","file","client_id","client_secret","redirect_url","market","id","secret","mar","existsSync","mkdirSync","spotifyData","SpotifyAuthorize","check_id","writeFileSync","cook","cookie","x","arr","key","value","attachListeners","player","resource","listeners","cleanup","pauseListener","resumeListener","idleListener","play_dl_default","DeezerAlbum","DeezerPlaylist","DeezerTrack","SoundCloudPlaylist","SoundCloudStream","SoundCloudTrack","SpotifyAlbum","SpotifyPlaylist","SpotifyTrack","YouTubeChannel","YouTubePlayList","YouTubeVideo","attachListeners","authorization","decipher_info","deezer","dz_advanced_track_search","dz_validate","extractID","getFreeClientID","is_expired","playlist_info","refreshToken","search","setToken","so_validate","soundcloud","spotify","sp_validate","stream","stream_from_info","validate","video_basic_info","video_info","yt_validate"]}